<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>fcntl函数</title>
      <link href="/2024/08/09/linux-fcntl-han-shu/"/>
      <url>/2024/08/09/linux-fcntl-han-shu/</url>
      
        <content type="html"><![CDATA[<p><code>fcntl</code> 是一个在 Unix 和 Linux 系统中广泛使用的系统调用，用于操作文件描述符。这个函数提供了一种灵活的方式来控制和管理文件描述符的各种属性和行为。</p><h3 id="fcntl-函数原型"><a href="#fcntl-函数原型" class="headerlink" title="fcntl 函数原型"></a><code>fcntl</code> 函数原型</h3><pre><code class="c">#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* arg */ );</code></pre><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol><li><p><strong><code>fd</code></strong>: 文件描述符，是一个正整数，表示一个打开的文件或设备。</p></li><li><p><strong><code>cmd</code></strong>: 操作命令，用于指定要执行的操作类型。常见的命令有以下几种：</p><ul><li><strong><code>F_DUPFD</code></strong>: 复制文件描述符，返回一个新的文件描述符，该文件描述符最小为 <code>arg</code>。</li><li><strong><code>F_GETFD</code></strong>: 获取文件描述符标志（file descriptor flags），返回 <code>FD_CLOEXEC</code> 的状态。</li><li><strong><code>F_SETFD</code></strong>: 设置文件描述符标志，可以用来设置 <code>FD_CLOEXEC</code>。</li><li><strong><code>F_GETFL</code></strong>: 获取文件状态标志（file status flags），例如 <code>O_RDONLY</code>、<code>O_NONBLOCK</code> 等。</li><li><strong><code>F_SETFL</code></strong>: 设置文件状态标志，可以设置文件的访问模式（例如将文件设置为非阻塞模式 <code>O_NONBLOCK</code>）。</li><li><strong><code>F_GETLK</code></strong>: 获取文件锁的状态。</li><li><strong><code>F_SETLK</code></strong>: 设置或清除文件锁，不会阻塞。如果不能获取锁，将返回错误。</li><li><strong><code>F_SETLKW</code></strong>: 与 <code>F_SETLK</code> 类似，但会阻塞直到锁可以被设置。</li><li><strong><code>F_GETOWN</code></strong>: 获取文件的所有者（通常用于异步 I&#x2F;O 操作的通知）。</li><li><strong><code>F_SETOWN</code></strong>: 设置文件的所有者。</li></ul></li><li><p><strong><code>arg</code></strong>: 可选参数，取决于 <code>cmd</code> 的值。有些命令需要传递一个整型值或指向结构的指针作为 <code>arg</code>。</p></li></ol><h3 id="常见用法示例"><a href="#常见用法示例" class="headerlink" title="常见用法示例"></a>常见用法示例</h3><h4 id="1-复制文件描述符"><a href="#1-复制文件描述符" class="headerlink" title="1. 复制文件描述符"></a>1. 复制文件描述符</h4><pre><code class="c">int new_fd = fcntl(fd, F_DUPFD, 0);</code></pre><p>复制 <code>fd</code> 并返回一个新的文件描述符 <code>new_fd</code>，两个描述符共享同一个打开的文件&#x2F;设备。</p><h4 id="2-获取和设置文件描述符标志"><a href="#2-获取和设置文件描述符标志" class="headerlink" title="2. 获取和设置文件描述符标志"></a>2. 获取和设置文件描述符标志</h4><pre><code class="c">int flags = fcntl(fd, F_GETFD); // 获取标志fcntl(fd, F_SETFD, flags | FD_CLOEXEC); // 设置 FD_CLOEXEC 标志</code></pre><p>这段代码在执行 exec 系列函数时关闭文件描述符。</p><h4 id="3-获取和设置文件状态标志"><a href="#3-获取和设置文件状态标志" class="headerlink" title="3. 获取和设置文件状态标志"></a>3. 获取和设置文件状态标志</h4><pre><code class="c">int flags = fcntl(fd, F_GETFL); // 获取当前的文件状态标志fcntl(fd, F_SETFL, flags | O_NONBLOCK); // 将文件设置为非阻塞模式</code></pre><p>这段代码将文件描述符设置为非阻塞模式。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><code>fcntl</code> 调用成功时返回正数（通常是新的文件描述符或命令的结果），如果失败则返回 <code>-1</code> 并设置 <code>errno</code> 以指示错误类型。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>fcntl</code> 是一个非常强大和灵活的系统调用，它可以用来管理文件描述符的各种属性，包括文件锁、非阻塞模式、文件描述符的复制等。它在系统编程中广泛用于控制和管理文件 I&#x2F;O 操作。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux递归遍历目录下文件,并判断文件类型</title>
      <link href="/2024/08/09/linux-di-gui-bian-li-mu-lu-xia-wen-jian/"/>
      <url>/2024/08/09/linux-di-gui-bian-li-mu-lu-xia-wen-jian/</url>
      
        <content type="html"><![CDATA[<pre><code class="cpp">#include &lt;iostream&gt;using namespace std;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;cerrno&gt;#include &lt;dirent.h&gt;void printFileType(const char *path)&#123;        struct stat sb;        if (stat(path, &amp;sb) == 0)        &#123;                if (S_ISREG(sb.st_mode))                &#123;                        std::cout &lt;&lt; &quot;Regular file: &quot; &lt;&lt; path &lt;&lt; std::endl;                &#125;                else if (S_ISDIR(sb.st_mode))                &#123;                        std::cout &lt;&lt; &quot;Directory: &quot; &lt;&lt; path &lt;&lt; std::endl;                &#125;                else if (S_ISBLK(sb.st_mode))                &#123;                        std::cout &lt;&lt; &quot;Block device: &quot; &lt;&lt; path &lt;&lt; std::endl;                &#125;                else if (S_ISCHR(sb.st_mode))                &#123;                        std::cout &lt;&lt; &quot;Character device: &quot; &lt;&lt; path &lt;&lt; std::endl;                &#125;                else if (S_ISFIFO(sb.st_mode))                &#123;                        std::cout &lt;&lt; &quot;FIFO/pipe: &quot; &lt;&lt; path &lt;&lt; std::endl;                &#125;                else if (S_ISSOCK(sb.st_mode))                &#123;                        std::cout &lt;&lt; &quot;Socket: &quot; &lt;&lt; path &lt;&lt; std::endl;                &#125;        &#125;        else        &#123;                std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; strerror(errno) &lt;&lt; std::endl;        &#125;&#125;void listDirectoryRecursively(const char* dirPath) &#123;    DIR* dir;    struct dirent* entry;    if ((dir = opendir(dirPath)) != NULL) &#123;        while ((entry = readdir(dir)) != NULL) &#123;            if (strcmp(entry-&gt;d_name, &quot;.&quot;) == 0 || strcmp(entry-&gt;d_name, &quot;..&quot;) == 0) &#123;                continue; // Skip current and parent directories to avoid infinite loop            &#125;            string filePath = dirPath;            if (filePath.back() != &#39;/&#39;) &#123;                filePath += &quot;/&quot;;            &#125;            filePath += entry-&gt;d_name;            printFileType(filePath.c_str());            if (entry-&gt;d_type == DT_DIR) &#123;                listDirectoryRecursively(filePath.c_str());            &#125;        &#125;        closedir(dir);    &#125; else &#123;        std::cerr &lt;&lt; &quot;Error opening directory: &quot; &lt;&lt; strerror(errno) &lt;&lt; std::endl;    &#125;&#125;int main()&#123;        listDirectoryRecursively(&quot;/home/zhao/mytest&quot;);            return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>给CentOS7根目录所对应的分区扩容</title>
      <link href="/2024/08/09/linux-kuo-rong/"/>
      <url>/2024/08/09/linux-kuo-rong/</url>
      
        <content type="html"><![CDATA[<p>给CentOS7根目录所对应的分区扩容</p><ol><li><p>输入命令进入编辑分区模式：<br><code>fdisk /dev/sda</code></p></li><li><p>因为我的根目录对应分区为&#x2F;dev&#x2F;sda3，所以我需要先删再新建&#x2F;dev&#x2F;sda3（在编辑分区模式下执行）:<br>**输入：d 回车 **</p><p><strong>默认3 : 回车</strong><br>PS：此步骤执行完成后，千万不要保存w，否则&#x2F;dev&#x2F;sda3就真的被删除了，那样&#x2F;dev&#x2F;sda3上的数据就被清空了，根目录下所有数据就都没了。<br><strong>输入：n 回车</strong><br><strong>新建分区类型输入：p 回车</strong><br><strong>选择分区默认3：回车</strong><br>起止扇区不输入任何内容，直接回车默认，将硬盘上剩余所有容量分给sda3</p></li><li><p>保存修改然后自动退出编辑分区模式：<br><strong>输入：w 回车</strong></p></li><li><p>重启(非编辑分区模式下执行)：<br><code>reboot</code></p></li><li><p>刷新分区大小(非编辑分区模式下执行)：<br><code>resize2fs /dev/sda3</code><br>PS：因为我的&#x2F;dev&#x2F;sda3分区是ext4文件系统，所以用resize2fs &#x2F;dev&#x2F;sda3，如果是xfs文件系统，那就用xfs_growfs &#x2F;dev&#x2F;sda3。</p></li></ol><p>ext 格式：resize2fs &#x2F;dev&#x2F;sda3<br>xfs 格式：xfs_growfs &#x2F;dev&#x2F;sda3</p><ol start="6"><li>最后查看根目录是否成功扩容(非编辑分区模式下执行)：<br><code>df -h</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>google搜索语法</title>
      <link href="/2024/08/08/google-sou-suo-yu-fa/"/>
      <url>/2024/08/08/google-sou-suo-yu-fa/</url>
      
        <content type="html"><![CDATA[<p>谷歌搜索提供了多种高级搜索语法和功能，帮助用户精准定位信息。以下是对谷歌搜索语法的全面介绍：</p><h3 id="1-精确短语匹配搜索"><a href="#1-精确短语匹配搜索" class="headerlink" title="1. 精确短语匹配搜索"></a>1. <strong>精确短语匹配搜索</strong></h3><ul><li><strong>语法</strong>: <code>&quot;&lt;关键词或短语&gt;&quot;</code></li><li><strong>示例</strong>: <code>&quot;machine learning&quot;</code></li><li><strong>功能</strong>: 搜索结果中只显示包含完全匹配短语的页面。这在寻找特定短语或引用时非常有用。</li></ul><h3 id="2-排除词搜索"><a href="#2-排除词搜索" class="headerlink" title="2. 排除词搜索"></a>2. <strong>排除词搜索</strong></h3><ul><li><strong>语法</strong>: <code>-&lt;排除的关键词&gt;</code></li><li><strong>示例</strong>: <code>jaguar -car</code></li><li><strong>功能</strong>: 排除包含特定词语的页面。这在寻找多义词时特别有用，例如要查找“jaguar”（美洲豹）而不是“jaguar”（汽车品牌）。</li></ul><h3 id="3-站内搜索"><a href="#3-站内搜索" class="headerlink" title="3. 站内搜索"></a>3. <strong>站内搜索</strong></h3><ul><li><strong>语法</strong>: <code>site:&lt;网站域名&gt; &lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>site:wikipedia.org Python</code></li><li><strong>功能</strong>: 限定搜索范围在特定网站内。这对于查找某个网站上的特定内容非常有用。</li></ul><h3 id="4-文件类型搜索"><a href="#4-文件类型搜索" class="headerlink" title="4. 文件类型搜索"></a>4. <strong>文件类型搜索</strong></h3><ul><li><strong>语法</strong>: <code>filetype:&lt;文件扩展名&gt; &lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>artificial intelligence filetype:pdf</code></li><li><strong>功能</strong>: 搜索特定文件类型的内容，如PDF、DOC、PPT等。适用于查找论文、报告或演示文档。</li></ul><h3 id="5-标题搜索"><a href="#5-标题搜索" class="headerlink" title="5. 标题搜索"></a>5. <strong>标题搜索</strong></h3><ul><li><strong>语法</strong>: <code>intitle:&lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>intitle:deep learning</code></li><li><strong>功能</strong>: 只搜索页面标题中包含指定词语的页面。标题通常是页面内容的摘要，标题中出现的关键词通常代表了页面的主要内容。</li></ul><h3 id="6-URL搜索"><a href="#6-URL搜索" class="headerlink" title="6. URL搜索"></a>6. <strong>URL搜索</strong></h3><ul><li><strong>语法</strong>: <code>inurl:&lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>inurl:login</code></li><li><strong>功能</strong>: 搜索URL中包含指定词语的页面。例如，可以用来查找特定页面类型，如登录页面、下载页面等。</li></ul><h3 id="7-文本内容搜索"><a href="#7-文本内容搜索" class="headerlink" title="7. 文本内容搜索"></a>7. <strong>文本内容搜索</strong></h3><ul><li><strong>语法</strong>: <code>intext:&lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>intext:&quot;neural network&quot;</code></li><li><strong>功能</strong>: 只搜索页面正文中包含指定关键词的页面。这种语法适用于希望找到内容中具体提到某些词汇的页面。</li></ul><h3 id="8-锚文本搜索"><a href="#8-锚文本搜索" class="headerlink" title="8. 锚文本搜索"></a>8. <strong>锚文本搜索</strong></h3><ul><li><strong>语法</strong>: <code>inanchor:&lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>inanchor:open source</code></li><li><strong>功能</strong>: 搜索锚文本（即链接文字）中包含指定关键词的页面。这有助于查找那些被特定文字链接指向的页面。</li></ul><h3 id="9-相关网站搜索"><a href="#9-相关网站搜索" class="headerlink" title="9. 相关网站搜索"></a>9. <strong>相关网站搜索</strong></h3><ul><li><strong>语法</strong>: <code>related:&lt;网站域名&gt;</code></li><li><strong>示例</strong>: <code>related:nytimes.com</code></li><li><strong>功能</strong>: 查找与指定网站内容类似的其他网站。例如，查找与《纽约时报》类似的新闻网站。</li></ul><h3 id="10-同义词搜索"><a href="#10-同义词搜索" class="headerlink" title="10. 同义词搜索"></a>10. <strong>同义词搜索</strong></h3><ul><li><strong>语法</strong>: <code>~&lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>~nutrition</code></li><li><strong>功能</strong>: 搜索包含指定关键词及其同义词的页面。谷歌会自动拓展词义范围，返回相关结果。</li></ul><h3 id="11-通配符搜索"><a href="#11-通配符搜索" class="headerlink" title="11. 通配符搜索"></a>11. <strong>通配符搜索</strong></h3><ul><li><strong>语法</strong>: <code>*</code></li><li><strong>示例</strong>: <code>artificial * network</code></li><li><strong>功能</strong>: 用作占位符，用于替代未知或任意的单词。谷歌会在搜索中自动填充合适的词语。</li></ul><h3 id="12-数字范围搜索"><a href="#12-数字范围搜索" class="headerlink" title="12. 数字范围搜索"></a>12. <strong>数字范围搜索</strong></h3><ul><li><strong>语法</strong>: <code>&lt;数字1&gt;..&lt;数字2&gt;</code></li><li><strong>示例</strong>: <code>laptop $500..$1000</code></li><li><strong>功能</strong>: 搜索指定范围内的数字或价格。例如查找价格在500到1000美元之间的笔记本电脑。</li></ul><h3 id="13-OR（或）搜索"><a href="#13-OR（或）搜索" class="headerlink" title="13. OR（或）搜索"></a>13. <strong>OR（或）搜索</strong></h3><ul><li><strong>语法</strong>: <code>&lt;关键词1&gt; OR &lt;关键词2&gt;</code> 或 <code>&lt;关键词1&gt; | &lt;关键词2&gt;</code></li><li><strong>示例</strong>: <code>python OR java</code></li><li><strong>功能</strong>: 搜索包含任一关键词的页面。用于扩大搜索范围，包含可能的多种选择。</li></ul><h3 id="14-定义搜索"><a href="#14-定义搜索" class="headerlink" title="14. 定义搜索"></a>14. <strong>定义搜索</strong></h3><ul><li><strong>语法</strong>: <code>define:&lt;词语&gt;</code></li><li><strong>示例</strong>: <code>define:quantum computing</code></li><li><strong>功能</strong>: 显示指定词语的定义。谷歌会提供简短的词语解释及相关资源。</li></ul><h3 id="15-缓存页面搜索"><a href="#15-缓存页面搜索" class="headerlink" title="15. 缓存页面搜索"></a>15. <strong>缓存页面搜索</strong></h3><ul><li><strong>语法</strong>: <code>cache:&lt;网页URL&gt;</code></li><li><strong>示例</strong>: <code>cache:example.com</code></li><li><strong>功能</strong>: 显示谷歌缓存的网页快照。这对访问临时不可用或已更改的网页非常有用。</li></ul><h3 id="16-链接到页面的外部链接"><a href="#16-链接到页面的外部链接" class="headerlink" title="16. 链接到页面的外部链接"></a>16. <strong>链接到页面的外部链接</strong></h3><ul><li><strong>语法</strong>: <code>link:&lt;网页URL&gt;</code></li><li><strong>示例</strong>: <code>link:wikipedia.org</code></li><li><strong>功能</strong>: 显示链接到指定网页的其他网站。这通常用于分析页面的反向链接情况。</li></ul><h3 id="17-特定语言搜索"><a href="#17-特定语言搜索" class="headerlink" title="17. 特定语言搜索"></a>17. <strong>特定语言搜索</strong></h3><ul><li><strong>语法</strong>: <code>lang:&lt;语言代码&gt; &lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>lang:es tutorial</code></li><li><strong>功能</strong>: 限定搜索范围为特定语言。例如，查找西班牙语的教程。</li></ul><h3 id="18-时间范围搜索"><a href="#18-时间范围搜索" class="headerlink" title="18. 时间范围搜索"></a>18. <strong>时间范围搜索</strong></h3><ul><li><strong>语法</strong>: 使用谷歌搜索工具栏中的“时间”选项，或通过“after:&lt;年份&gt; before:&lt;年份&gt;”语法。</li><li><strong>示例</strong>: <code>climate change after:2010 before:2020</code></li><li><strong>功能</strong>: 搜索特定时间范围内发布的内容。例如，查找2010到2020年间关于气候变化的文章。</li></ul><h3 id="19-特定位置搜索"><a href="#19-特定位置搜索" class="headerlink" title="19. 特定位置搜索"></a>19. <strong>特定位置搜索</strong></h3><ul><li><strong>语法</strong>: <code>location:&lt;地理位置&gt;</code></li><li><strong>示例</strong>: <code>best restaurants location:London</code></li><li><strong>功能</strong>: 搜索特定地理位置相关的信息。这对于查找本地信息或特定地区的新闻很有帮助。</li></ul><h3 id="20-符号识别"><a href="#20-符号识别" class="headerlink" title="20. 符号识别"></a>20. <strong>符号识别</strong></h3><ul><li><strong>示例</strong>:<ul><li><code>@</code>: 用于搜索社交媒体内容，例如 <code>@OpenAI</code></li><li><code>#</code>: 用于搜索热门话题标签，例如 <code>#AI</code></li></ul></li><li><strong>功能</strong>: 帮助查找社交媒体上的内容和趋势。</li></ul><h3 id="21-组合使用"><a href="#21-组合使用" class="headerlink" title="21. 组合使用"></a>21. <strong>组合使用</strong></h3><ul><li><strong>示例</strong>: <code>intitle:&quot;machine learning&quot; site:edu filetype:pdf</code></li><li><strong>功能</strong>: 可以将多个搜索语法组合在一起，以进行更复杂和精确的搜索。</li></ul><h3 id="22-翻译工具"><a href="#22-翻译工具" class="headerlink" title="22. 翻译工具"></a>22. <strong>翻译工具</strong></h3><ul><li><strong>语法</strong>: <code>translate &lt;词语&gt; to &lt;语言&gt;</code></li><li><strong>示例</strong>: <code>translate love to Spanish</code></li><li><strong>功能</strong>: 快速翻译单词或短语。</li></ul><h3 id="23-股票查询"><a href="#23-股票查询" class="headerlink" title="23. 股票查询"></a>23. <strong>股票查询</strong></h3><ul><li><strong>语法</strong>: <code>&lt;股票代码&gt;</code></li><li><strong>示例</strong>: <code>AAPL</code></li><li><strong>功能</strong>: 显示指定股票的最新价格和市场数据。</li></ul><h3 id="24-天气查询"><a href="#24-天气查询" class="headerlink" title="24. 天气查询"></a>24. <strong>天气查询</strong></h3><ul><li><strong>语法</strong>: <code>weather &lt;城市名&gt;</code></li><li><strong>示例</strong>: <code>weather New York</code></li><li><strong>功能</strong>: 显示指定城市的天气预报。</li></ul><h3 id="25-时间查询"><a href="#25-时间查询" class="headerlink" title="25. 时间查询"></a>25. <strong>时间查询</strong></h3><ul><li><strong>语法</strong>: <code>time &lt;城市名&gt;</code></li><li><strong>示例</strong>: <code>time Tokyo</code></li><li><strong>功能</strong>: 显示指定城市的当前时间。</li></ul><h3 id="26-计量单位换算"><a href="#26-计量单位换算" class="headerlink" title="26. 计量单位换算"></a>26. <strong>计量单位换算</strong></h3><ul><li><strong>语法</strong>: <code>&lt;数值&gt;&lt;原单位&gt; to &lt;目标单位&gt;</code></li><li><strong>示例</strong>: <code>10kg to lbs</code></li><li><strong>功能</strong>: 进行单位换算，例如重量、长度、温度等。</li></ul><h3 id="27-计算器功能"><a href="#27-计算器功能" class="headerlink" title="27. 计算器功能"></a>27. <strong>计算器功能</strong></h3><ul><li><strong>语法</strong>: 直接输入数学表达式</li><li><strong>示例</strong>: <code>2+2</code> 或 <code>sqrt(16)</code></li><li><strong>功能</strong>: 进行简单或复杂的数学计算。</li></ul><h3 id="28-航班信息"><a href="#28-航班信息" class="headerlink" title="28. 航班信息"></a>28. <strong>航班信息</strong></h3><ul><li><strong>语法</strong>: <code>&lt;航班号&gt;</code></li><li><strong>示例</strong>: <code>UA882</code></li><li><strong>功能</strong>: 显示航班的状态、时间和终点站信息。</li></ul><h3 id="29-快递包裹跟踪"><a href="#29-快递包裹跟踪" class="headerlink" title="29. 快递包裹跟踪"></a>29. <strong>快递包裹跟踪</strong></h3><ul><li><strong>语法</strong>: 直接输入追踪号</li><li><strong>示例</strong>: <code>1Z999AA10123456784</code></li><li><strong>功能</strong>: 跟踪快递包裹的状态。</li></ul><p>通过掌握这些搜索语法，你可以大大提高在谷歌上的搜索效率，快速找到所需信息。这些工具和技巧适用于不同的需求，无论是学术研究、工作查询，还是日常信息检索。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>B+树</title>
      <link href="/2024/08/08/b-shu/"/>
      <url>/2024/08/08/b-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1tJ4m1w7yR/?spm_id_from=333.788&vd_source=22c6cdd1f2942942ebeae1c234b5b8f2">https://www.bilibili.com/video/BV1tJ4m1w7yR/?spm_id_from=333.788&amp;vd_source=22c6cdd1f2942942ebeae1c234b5b8f2</a></p><p><img src="/images/Snipaste_2024-08-08_17-03-42.png"></p><p>B+树是一种自平衡的树数据结构，广泛应用于数据库和文件系统等场景。它是一种N叉树（通常为B树的一种变体），具有较高的查找、插入和删除操作效率。<strong>支持顺序查找、随机查找、范围查找。</strong>以下是对B+树的详细介绍。</p><h3 id="B-树的基本概念"><a href="#B-树的基本概念" class="headerlink" title="B+树的基本概念"></a>B+树的基本概念</h3><ol><li><p><strong>节点结构</strong>:</p><ul><li><strong>内部节点（Internal Nodes）</strong>: 只存储索引键，不存储实际数据，每个节点包含指向子节点的指针。</li><li><strong>叶子节点（Leaf Nodes）</strong>: 存储实际数据（即关键字和数据记录），并按顺序链成一个双向链表，便于范围查询。</li><li><strong>阶（Degree）</strong>: B+树的阶（通常记为<code>m</code>）是指每个节点的最大子节点个数。每个内部节点包含<code>k</code>个键和<code>k+1</code>个指针（<code>⌈m/2⌉ ≤ k ≤ m</code>）。</li></ul></li><li><p><strong>性质</strong>:</p><ul><li>所有叶子节点在同一层。</li><li>内部节点用于导航，叶子节点存储实际数据。</li><li>内部节点包含<code>k</code>个键值，指向<code>k+1</code>个子节点。</li><li>根节点至少有两个子节点（除非是空树或只有一个节点的树）。</li><li>非根节点的子节点个数至少为<code>⌈m/2⌉</code>。</li></ul></li><li><p><strong>高度</strong>:</p><ul><li>B+树的高度一般较低，因为每个节点可以包含多个键值和指针，这使得树的高度相对较小，进而提高了查找效率。</li></ul></li></ol><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol><li><p><strong>查找</strong>:</p><ul><li>从根节点开始，通过比较当前节点的键值，决定沿哪个子节点继续查找，直到叶子节点。</li><li>一旦到达叶子节点，便可在其中找到所需的数据。</li></ul></li><li><p><strong>插入</strong>:</p><ul><li>首先定位插入位置，即通过查找操作找到应该插入的叶子节点。</li><li>将新数据插入该叶子节点。如果节点已满，则需要进行节点分裂，并将中间值提升到父节点。如果父节点也满，则继续向上分裂，直到根节点。若根节点也分裂，树的高度增加。</li></ul></li><li><p><strong>删除</strong>:</p><ul><li>定位要删除的节点，首先通过查找操作找到目标叶子节点。</li><li>删除数据后，如果节点下溢（即子节点个数少于<code>⌈m/2⌉</code>），则需要借用兄弟节点的键值，或合并节点。如果父节点的键值因此减少，也可能需要向上调整或合并。</li></ul></li></ol><h3 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h3><ol><li><p><strong>范围查询高效</strong>:</p><ul><li>由于所有实际数据都在叶子节点且叶子节点通过指针相连，B+树能够非常高效地进行范围查询（例如找到某个范围内的所有值）。</li></ul></li><li><p><strong>更好的磁盘读写性能</strong>:</p><ul><li>B+树内部节点通常只存储索引，节点高度较低，使得查找路径较短，减少了磁盘I&#x2F;O次数。</li></ul></li><li><p><strong>支持批量查找和顺序访问</strong>:</p><ul><li>由于叶子节点通过链表连接，可以非常方便地进行顺序访问和批量处理。</li></ul></li><li><p><strong>稳定性</strong>:</p><ul><li>B+树的高度是平衡的，确保了所有插入、删除和查找操作的时间复杂度都是<code>O(log n)</code>。</li></ul></li></ol><h3 id="B-树与B树的区别"><a href="#B-树与B树的区别" class="headerlink" title="B+树与B树的区别"></a>B+树与B树的区别</h3><ul><li><strong>数据存储位置</strong>: B+树的数据仅存储在叶子节点中，而B树的数据既可以存储在叶子节点中，也可以存储在内部节点中。</li><li><strong>节点结构</strong>: B+树的内部节点不存储实际数据，只存储索引，而B树的内部节点可以存储数据。</li><li><strong>顺序访问</strong>: B+树叶子节点通过链表相连，支持顺序遍历，而B树没有这样的机制。</li><li><strong>树高度</strong>: B+树通常比B树更矮，因为B+树的内部节点更紧凑，且每个节点能存储更多索引。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>数据库索引</strong>: B+树广泛用于关系型数据库的索引结构，如MySQL的InnoDB存储引擎使用B+树作为主索引和二级索引的实现方式。</li><li><strong>文件系统</strong>: B+树也用于文件系统中的元数据管理，如NTFS文件系统。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>B+树是一种高效的树结构，特别适用于需要频繁进行范围查询和顺序访问的场景。它通过将数据集中存储在叶子节点并使用链表连接叶子节点，提高了查询效率和顺序访问的性能。</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B树，又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树：<br>1）树中每个结点至多有m棵子树，即至多含有m-1个关键字。<br>2）若根结点不是终端结点，则至少有两棵子树。<br>3）除根结点外的所有非叶结点至少有⌈m&#x2F;2⌉棵子树，即至少含有⌈m&#x2F;2⌉-1个关键字。<br>4）所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跳表</title>
      <link href="/2024/08/07/tiao-biao/"/>
      <url>/2024/08/07/tiao-biao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV16Y411J7sT/?spm_id_from=333.337.search-card.all.click&vd_source=22c6cdd1f2942942ebeae1c234b5b8f2">https://www.bilibili.com/video/BV16Y411J7sT/?spm_id_from=333.337.search-card.all.click&amp;vd_source=22c6cdd1f2942942ebeae1c234b5b8f2</a></p><p>跳表（Skip List）是一种用于有序数据存储的数据结构，允许快速查询、插入和删除操作。跳表在很多方面与平衡树（如 AVL 树或红黑树）相似，但更简单且易于实现。它通过在链表的基础上增加多层索引来实现快速操作。</p><h3 id="跳表的基本结构"><a href="#跳表的基本结构" class="headerlink" title="跳表的基本结构"></a>跳表的基本结构</h3><p>跳表由多层链表组成，底层是一个有序的链表，每一层都是从底层链表中抽取的一些结点组成的链表。每一层链表包含的结点数量逐层减少，顶层链表通常只有一个结点。</p><h3 id="跳表的示意图"><a href="#跳表的示意图" class="headerlink" title="跳表的示意图"></a>跳表的示意图</h3><p>假设我们有一个包含整数的跳表：</p><pre><code>Level 3:       1---------------------12----------------------Level 2:       1-------5-------9------12---------------------Level 1:       1--3----5--7----9--10--12---------------------Level 0:       1--2--3--4--5--6--7--8--9--10--11--12--13--14</code></pre><h3 id="跳表的操作"><a href="#跳表的操作" class="headerlink" title="跳表的操作"></a>跳表的操作</h3><ol><li><p><strong>查找（Search）</strong>：</p><ul><li>从顶层开始查找，从左到右移动，直到找到大于或等于目标值的结点。</li><li>如果找到目标值，查找结束；如果没有，向下一层继续查找。</li><li>在每一层，移动的步数较少，因为层级越高，结点越稀疏。</li></ul></li><li><p><strong>插入（Insert）</strong>：</p><ul><li>插入操作首先需要找到插入位置，即找到比新值小且最接近的结点。</li><li>插入结点后，决定新结点的层数（通常使用随机化方法，如抛硬币）。</li><li>将新结点插入到所有相关层的链表中。</li></ul></li><li><p><strong>删除（Delete）</strong>：</p><ul><li>删除操作首先需要找到目标结点在每一层的位置。</li><li>然后从每一层的链表中移除该结点。</li></ul></li></ol><h3 id="跳表的复杂度分析"><a href="#跳表的复杂度分析" class="headerlink" title="跳表的复杂度分析"></a>跳表的复杂度分析</h3><p>跳表的时间复杂度可以近似为 O(log n)，这是因为跳表的高度大约为 O(log n)，每层的搜索和插入操作平均需要 O(1) 的时间。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="cpp">class Skiplist &#123;public:    static const int level = 8; // 层数，经验值 8，太大浪费空间，因为每一个节点都要存在每一层的 next，层数越多节点数越多    // 定义跳表节点    struct Node &#123;        int val; // 节点值        vector&lt;Node*&gt; next; // 记录节点在每一层的 next，next[i] 表示当前节点第 i 层的 next        Node(int _val) : val(_val) &#123; // 构造函数            next.resize(level, NULL); // 初始化 next 数组的大小和层数 level 相同，初始值都指向 NULL        &#125;    &#125;*head; // 定义头节点 head    Skiplist() &#123;        head = new Node(-1); // 初始化一个不存在的节点值 -1    &#125;    ~Skiplist() &#123;        delete head; // 析构函数删除 head    &#125;    // 辅助函数：找到每一层 i 小于目标值 target 的最大节点 pre[i]，最后 pre 中存的就是每一层小于 target 的最大节点    void find(int target, vector&lt;Node*&gt;&amp; pre) &#123;        auto p = head; // 从头节点开始遍历每一层        for (int i = level - 1; i &gt;= 0; i -- ) &#123; // 从上层往下层找            while (p-&gt;next[i] &amp;&amp; p-&gt;next[i]-&gt;val &lt; target) p = p-&gt;next[i]; // 如果当前层 i 的 next 不为空，且它的值小于 target，则 p 往后走指向这一层 p 的 next            pre[i] = p; // 退出 while 时说明找到了第 i 层小于 target 的最大节点就是 p        &#125;    &#125;        // 从跳表中查找 target    bool search(int target) &#123;        vector&lt;Node*&gt; pre(level);        find(target, pre); // 先找到每一层 i 小于目标值 target 的最大节点 pre[i]                auto p = pre[0]-&gt;next[0]; // 因为最下层【0】的节点是全的，所以只需要判断 target 是否在第 0 层即可，而 pre[0] 正好就是小于 target 的最大节点，如果 pre[0]-&gt;next[0] 的值不是 target 说明没有这个元素        return p &amp;&amp; p-&gt;val == target;    &#125;        // 向跳表中插入元素 num    void add(int num) &#123;        vector&lt;Node*&gt; pre(level);        find(num, pre); // 先找到每一层 i 小于目标值 target 的最大节点 pre[i]        auto p = new Node(num); // 创建要插入的新节点        for (int i = 0; i &lt; level; i ++ ) &#123; // 遍历每一层，从下往上插入新节点            p-&gt;next[i] = pre[i]-&gt;next[i]; // 这两步就是单链表的插入            pre[i]-&gt;next[i] = p;            if (rand() % 2) break; // 每一层有 50% 的概率不插入新节点        &#125;    &#125;        // 从跳表中删除 num    bool erase(int num) &#123;        vector&lt;Node*&gt; pre(level);        find(num, pre); // 先找到每一层 i 小于目标值 target 的最大节点 pre[i]        // 先判断 num 是否存在，不存在直接返回 false        // 第 0 层存储的是全部节点，所以只需要判断 pre[0]-&gt;next[0]（第 0 层小于 num 的最大节点的在第 0 层的 next） 是不是 num 即可        auto p = pre[0]-&gt;next[0];        if (!p || p-&gt;val != num) return false;        // 否则删除每一层的 num，如果 pre[i]-&gt;next[i] == p 说明第 i 层存在 p        for (int i = 0; i &lt; level &amp;&amp; pre[i]-&gt;next[i] == p; i ++ ) &#123;            pre[i]-&gt;next[i] = p-&gt;next[i]; // 单链表删除        &#125;        delete p; // 删除节点 p，防止内存泄漏        return true;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11条件变量</title>
      <link href="/2024/08/06/c-11-tiao-jian-bian-liang/"/>
      <url>/2024/08/06/c-11-tiao-jian-bian-liang/</url>
      
        <content type="html"><![CDATA[<p>在 C++11 中，<code>std::condition_variable</code> 的 <code>wait</code> 方法用于使线程在某个条件满足之前等待，并自动释放和重新获得互斥量。下面详细解释 <code>cv.wait(lock, [] &#123; return ready; &#125;);</code> 这行代码的作用和工作原理：</p><h3 id="cv-wait-lock-return-ready-解释"><a href="#cv-wait-lock-return-ready-解释" class="headerlink" title="cv.wait(lock, [] { return ready; }); 解释"></a><code>cv.wait(lock, [] &#123; return ready; &#125;);</code> 解释</h3><ol><li><p><strong><code>cv.wait()</code> 方法</strong>:</p><ul><li><code>cv.wait()</code> 是 <code>std::condition_variable</code> 的一个成员函数，用于使线程等待，直到条件变量被通知，并且条件满足。</li><li>它接受两个参数：<ul><li>一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象，用于与条件变量相关联的互斥量。</li><li>一个可调用对象（如 lambda 表达式、函数对象），用于检查条件是否满足。</li></ul></li></ul></li><li><p><strong>参数 <code>lock</code></strong>:</p><ul><li><code>lock</code> 是一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象，表示在调用 <code>wait</code> 时持有的互斥量。</li><li><code>std::unique_lock</code> 提供了更灵活的锁管理功能，与 <code>std::mutex</code> 一起使用。</li></ul></li><li><p><strong>参数 <code>[] &#123; return ready; &#125;</code></strong>:</p><ul><li>这是一个 lambda 表达式，作为条件检查的函数。</li><li>它检查 <code>ready</code> 标志是否为 <code>true</code>。</li><li>如果 <code>ready</code> 为 <code>true</code>，表示条件满足，<code>wait</code> 方法将返回，线程继续执行。</li><li>如果 <code>ready</code> 为 <code>false</code>，线程将继续等待，直到条件变量被通知且条件满足。</li></ul></li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p><strong>进入 <code>wait</code></strong>:</p><ul><li>线程调用 <code>cv.wait(lock, [] &#123; return ready; &#125;);</code>，它会释放与 <code>lock</code> 相关联的互斥量，进入等待状态。</li><li>在等待期间，线程不会持有互斥量，允许其他线程修改 <code>ready</code> 标志或执行其他操作。</li></ul></li><li><p><strong>条件检查</strong>:</p><ul><li>在进入等待状态之前，线程会检查 <code>ready</code> 标志。</li><li>如果 <code>ready</code> 为 <code>true</code>，线程将不会进入等待状态，直接返回。</li><li>如果 <code>ready</code> 为 <code>false</code>，线程将进入等待状态，并等待条件变量的通知。</li></ul></li><li><p><strong>通知和重新获取锁</strong>:</p><ul><li>当其他线程改变条件并调用 <code>cv.notify_one()</code> 或 <code>cv.notify_all()</code> 时，条件变量会唤醒等待的线程。</li><li>被唤醒的线程会重新获得 <code>lock</code> 互斥量，并重新检查条件。</li><li>线程在重新获得锁后，执行 lambda 表达式检查条件是否满足。</li><li>如果条件满足，线程继续执行。如果条件不满足，线程将继续等待。</li></ul></li><li><p><strong>继续执行</strong>:</p><ul><li>一旦条件满足，线程将退出 <code>wait</code> 状态，重新获得互斥量，继续执行后续代码。</li></ul></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个使用条件变量的完整示例，其中 <code>cv.wait()</code> 用于等待生产者线程准备数据：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;std::queue&lt;int&gt; data_queue;std::mutex mtx;std::condition_variable cv;bool ready = false;void producer() &#123;    std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟生产过程    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        data_queue.push(42); // 放入数据        ready = true; // 标记数据准备好了    &#125;    cv.notify_one(); // 通知消费者线程&#125;void consumer() &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx);    cv.wait(lock, [] &#123; return ready; &#125;); // 等待直到数据准备好    int data = data_queue.front(); // 获取数据    data_queue.pop();    std::cout &lt;&lt; &quot;Consumed: &quot; &lt;&lt; data &lt;&lt; std::endl;&#125;int main() &#123;    std::thread prod(producer);    std::thread cons(consumer);    prod.join();    cons.join();    return 0;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>cv.wait(lock, [] &#123; return ready; &#125;);</code> 是一种等待机制，线程会在 <code>ready</code> 条件满足之前挂起，直到条件变量被通知并条件满足后才会继续执行。</li><li>在等待期间，线程释放了互斥量，使得其他线程可以访问共享资源。</li><li><code>wait</code> 方法会自动重新获取互斥量，并在条件变量被通知后继续执行，确保数据的一致性和线程安全。</li></ul><p>在使用 <code>std::condition_variable</code> 时，<strong>检查条件值</strong>ready是非常重要的，尽管条件变量会通知等待的线程。但是，如果在等待期间不检查条件值，可能会导致逻辑错误或未定义的行为。</p><h3 id="为什么需要检查条件值"><a href="#为什么需要检查条件值" class="headerlink" title="为什么需要检查条件值"></a>为什么需要检查条件值</h3><ol><li><p><strong>虚假唤醒</strong>:</p><ul><li>条件变量的 <code>wait</code> 方法在某些情况下可能会发生虚假唤醒。虚假唤醒是指线程被唤醒时，条件变量没有实际满足预期条件。在这种情况下，线程必须重新检查条件是否真正满足。</li><li>如果不检查条件值，线程可能在条件未满足时继续执行，导致错误的程序行为。</li></ul></li><li><p><strong>避免竞争条件</strong>:</p><ul><li>条件变量与互斥量一起使用时，条件变量的通知可能发生在线程正在等待时。如果线程在通知发生时还没有完全释放互斥量，可能会出现竞争条件。</li><li>通过检查条件值，可以确保只有在条件真正满足时，线程才会继续执行，避免了可能的数据竞争问题。</li></ul></li><li><p><strong>代码正确性</strong>:</p><ul><li>在许多实际应用中，条件变量用于处理复杂的同步和协调任务。检查条件值可以确保线程按照预期的逻辑流程运行，避免由于条件不满足导致的错误。</li></ul></li></ol><h3 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h3><p>下面是一个没有检查条件值的例子，展示了为什么检查条件值是重要的：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;std::mutex mtx;std::condition_variable cv;bool ready = false;void producer() &#123;    std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟生产过程    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        ready = true; // 标记数据准备好了    &#125;    cv.notify_one(); // 通知消费者线程&#125;void consumer() &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx);    cv.wait(lock); // 不检查条件值    // 由于没有检查条件值，线程可能在条件未满足时继续执行    if (ready) &#123;        std::cout &lt;&lt; &quot;Condition is met.&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;Condition is not met.&quot; &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    std::thread prod(producer);    std::thread cons(consumer);    prod.join();    cons.join();    return 0;&#125;</code></pre><p>在上面的代码中，<code>cv.wait(lock)</code> 不检查条件值。尽管我们在生产者线程中设置了 <code>ready = true</code> 并通知了条件变量，但消费者线程在 <code>wait</code> 后可能会继续执行而没有检查条件值。这可能会导致错误输出或逻辑不一致。</p><h3 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h3><p>为了确保线程在条件满足时才继续执行，应使用 <code>wait</code> 方法的重载版本，它接受一个条件检查函数。例如：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;std::mutex mtx;std::condition_variable cv;bool ready = false;void producer() &#123;    std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟生产过程    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        ready = true; // 标记数据准备好了    &#125;    cv.notify_one(); // 通知消费者线程&#125;void consumer() &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx);    cv.wait(lock, [] &#123; return ready; &#125;); // 检查条件值    std::cout &lt;&lt; &quot;Condition is met.&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::thread prod(producer);    std::thread cons(consumer);    prod.join();    cons.join();    return 0;&#125;</code></pre><p>在这个例子中，<code>cv.wait(lock, [] &#123; return ready; &#125;);</code> 检查 <code>ready</code> 条件值，确保只有在条件真正满足时消费者线程才会继续执行。这样可以避免虚假唤醒和其他潜在的同步问题。</p><p>生产者-消费者模型是多线程编程中的经典问题，其主要任务是协调生产者线程和消费者线程，以便在生产和消费之间保持平衡。条件变量（<code>std::condition_variable</code>）是实现这一模型的一个重要工具，因为它提供了一种机制来协调和通知线程何时可以生产或消费数据。</p><h3 id="为什么使用条件变量"><a href="#为什么使用条件变量" class="headerlink" title="为什么使用条件变量"></a>为什么使用条件变量</h3><ol><li><p><strong>线程同步</strong>:</p><ul><li>条件变量可以用来同步生产者和消费者线程。当生产者线程产生新数据时，它可以通知消费者线程数据已准备好。当消费者线程处理完数据后，它可以通知生产者线程可以继续生产。条件变量帮助保证线程之间的正确同步和数据一致性。</li></ul></li><li><p><strong>避免忙等待</strong>:</p><ul><li>在没有条件变量的情况下，消费者线程可能会忙等待（不断检查是否有新数据）以决定是否继续执行。这会浪费 CPU 时间和资源，降低程序效率。使用条件变量可以使线程在没有数据可处理时挂起，直到有数据准备好为止，从而减少 CPU 使用率。</li></ul></li><li><p><strong>处理资源共享</strong>:</p><ul><li>条件变量与互斥量（<code>std::mutex</code>）一起使用，可以确保线程在访问共享资源（如缓冲区）时的安全性。在生产者线程将数据放入缓冲区时，它会锁定互斥量，并在放入数据后通知消费者线程。同样，消费者线程在获取数据前也会锁定互斥量，确保数据的正确性。</li></ul></li><li><p><strong>动态调整</strong>:</p><ul><li>条件变量允许生产者和消费者根据实际的生产和消费速度动态调整。这意味着生产者可以在缓冲区已满时暂停生产，而消费者可以在缓冲区为空时暂停消费。这样可以更灵活地适应不同的生产和消费速率。</li></ul></li></ol><h3 id="生产者-消费者模型示例"><a href="#生产者-消费者模型示例" class="headerlink" title="生产者-消费者模型示例"></a>生产者-消费者模型示例</h3><p>下面是一个使用条件变量的生产者-消费者示例，展示了如何使用条件变量来协调生产者和消费者线程：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;std::queue&lt;int&gt; data_queue; // 数据队列std::mutex mtx; // 互斥量std::condition_variable cv; // 条件变量const unsigned int max_queue_size = 10; // 最大队列大小void producer() &#123;    int data = 0;    while (true) &#123;        &#123;            std::unique_lock&lt;std::mutex&gt; lock(mtx);            cv.wait(lock, [] &#123; return data_queue.size() &lt; max_queue_size; &#125;); // 等待直到有空间            data_queue.push(data++); // 生产数据            std::cout &lt;&lt; &quot;Produced: &quot; &lt;&lt; data - 1 &lt;&lt; std::endl;        &#125;        cv.notify_all(); // 通知消费者线程        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟生产延迟    &#125;&#125;void consumer() &#123;    while (true) &#123;        int data;        &#123;            std::unique_lock&lt;std::mutex&gt; lock(mtx);            cv.wait(lock, [] &#123; return !data_queue.empty(); &#125;); // 等待直到有数据            data = data_queue.front(); // 消费数据            data_queue.pop();            std::cout &lt;&lt; &quot;Consumed: &quot; &lt;&lt; data &lt;&lt; std::endl;        &#125;        cv.notify_all(); // 通知生产者线程        std::this_thread::sleep_for(std::chrono::milliseconds(150)); // 模拟消费延迟    &#125;&#125;int main() &#123;    std::thread prod_thread(producer);    std::thread cons_thread(consumer);    prod_thread.join();    cons_thread.join();    return 0;&#125;</code></pre><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol><li><p><strong>生产者线程</strong>:</p><ul><li>在生产者线程中，使用 <code>cv.wait()</code> 等待直到队列有空间可以添加新数据。</li><li>生产数据后，使用 <code>cv.notify_all()</code> 通知所有等待的消费者线程，表示数据已准备好。</li></ul></li><li><p><strong>消费者线程</strong>:</p><ul><li>在消费者线程中，使用 <code>cv.wait()</code> 等待直到队列中有数据可以消费。</li><li>消费数据后，使用 <code>cv.notify_all()</code> 通知所有等待的生产者线程，表示队列中有空位可以添加新数据。</li></ul></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>条件变量是生产者-消费者模型中实现线程同步和协调的重要工具。它们通过提供一种机制来等待和通知线程，帮助有效地管理资源共享、避免忙等待，并允许线程根据实际情况动态调整生产和消费行为。通过合理使用条件变量，可以确保生产者和消费者线程之间的有效协作和程序的高效运行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11新特性</title>
      <link href="/2024/08/06/c-11-xin-te-xing/"/>
      <url>/2024/08/06/c-11-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<hr><p><code>int sum&#123;&#125;;</code> 是 C++11 引入的一个特性，用于初始化变量。这里的 <code>&#123;&#125;</code> 是一种 <strong>统一初始化</strong> 语法，它在 C++11 中引入并扩展了初始化的方式。</p><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ol><li><p><strong>值初始化</strong></p><p>当使用 <code>int sum&#123;&#125;;</code> 时，变量 <code>sum</code> 被值初始化。对于基本类型（如 <code>int</code>），值初始化将变量初始化为其默认值。在这种情况下，<code>int</code> 类型的变量将被初始化为 <code>0</code>。</p><pre><code class="cpp">int sum&#123;&#125;;  // sum 被初始化为 0</code></pre><p>这种初始化方式可以确保变量在声明时被初始化为确定的值，防止未初始化的变量导致潜在的错误。</p></li><li><p><strong>统一初始化语法</strong></p><p>C++11 引入了统一初始化语法 <code>&#123;&#125;</code>，使得初始化各种类型的变量变得一致。这种语法的主要好处包括：</p><ul><li><strong>防止窄化转换</strong>：使用 <code>&#123;&#125;</code> 语法时，如果初始化值的类型不能隐式转换为变量的类型，编译器会报错。例如，<code>int x&#123;3.14&#125;;</code> 会导致编译错误，因为 <code>3.14</code> 是 <code>double</code> 类型，而不能隐式转换为 <code>int</code>。</li><li><strong>统一的初始化方式</strong>：不论是内置类型还是自定义类型（如类和结构体），都可以使用 <code>&#123;&#125;</code> 进行初始化，提供了一致性。</li></ul><pre><code class="cpp">int x&#123;5&#125;;         // 初始化为 5double y&#123;3.14&#125;;   // 初始化为 3.14std::vector&lt;int&gt; v&#123;1, 2, 3&#125;; // 初始化 std::vector</code></pre></li><li><p><strong>值初始化 vs. 默认初始化</strong></p><ul><li><strong>值初始化</strong>：当变量在声明时使用 <code>&#123;&#125;</code> 进行初始化时，如 <code>int sum&#123;&#125;;</code>，它将被初始化为零或相应的默认值。</li><li><strong>默认初始化</strong>：当变量未显式初始化时，它的值是未定义的（对于基本类型）。例如，<code>int x;</code> 的值是未定义的，需要显式初始化以避免使用未定义值的风险。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>int sum&#123;&#125;;</code> 是 C++11 的统一初始化语法的一部分，它通过使用 <code>&#123;&#125;</code> 进行值初始化，将变量 <code>sum</code> 初始化为 <code>0</code>。这种语法简化了初始化的方式，并帮助防止潜在的错误。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11类型强制转换</title>
      <link href="/2024/08/05/c-11-lei-xing-qiang-zhi-zhuan-huan/"/>
      <url>/2024/08/05/c-11-lei-xing-qiang-zhi-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<p>在C++中，有四种主要的强制类型转换运算符：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code> 和 <code>reinterpret_cast</code>。每种类型转换运算符在编译时或运行时执行不同的检查。</p><h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. <code>static_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于进行隐式转换和显式转换。</li><li>适用于基本数据类型之间的转换、类层次结构中的上行转换（从派生类到基类）和下行转换（从基类到派生类，但无运行时检查）。</li><li>编译器在编译时进行类型检查，确保转换是有效的。</li></ul><pre><code class="cpp">int main() &#123;    int a = 10;    double b = static_cast&lt;double&gt;(a); // 编译时转换    return 0;&#125;</code></pre><h3 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. <code>dynamic_cast</code></h3><p><strong>检测时刻：运行时</strong></p><ul><li>主要用于多态类型转换（基类指针&#x2F;引用到派生类指针&#x2F;引用）。</li><li>需要基类有至少一个虚函数，以启用运行时类型信息（RTTI）。</li><li>在运行时进行类型检查，如果转换失败，指针类型返回 <code>nullptr</code>，引用类型抛出 <code>std::bad_cast</code> 异常。</li></ul><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base &#123;public:    virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;int main() &#123;    Base* basePtr = new Derived();    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);    if (derivedPtr) &#123;        derivedPtr-&gt;derivedFunction(); // 运行时转换    &#125; else &#123;        std::cout &lt;&lt; &quot;Conversion failed&quot; &lt;&lt; std::endl;    &#125;    delete basePtr;    return 0;&#125;</code></pre><h3 id="3-const-cast"><a href="#3-const-cast" class="headerlink" title="3. const_cast"></a>3. <code>const_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于修改类型的 <code>const</code> 或 <code>volatile</code> 属性。</li><li>主要用于将 <code>const</code> 指针或引用转换为非 <code>const</code>，反之亦然。</li><li>编译器在编译时进行类型检查。</li></ul><pre><code class="cpp">int main() &#123;    const int a = 10;    int* p = const_cast&lt;int*&gt;(&amp;a); // 编译时转换    *p = 20; // 可能导致未定义行为    // 10    /*    原因：因为编译器可能会将 const 变量的值内联到代码中，因此即使修改了内存中的值，输出结果仍可能显示原始的 const 值。    */    cout&lt;&lt;a&lt;&lt;endl;    return 0;&#125;</code></pre><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. <code>reinterpret_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于进行低级别的、无类型安全检查的转换。</li><li>适用于指针类型之间的转换、将指针转换为整数类型或反之。</li><li>编译器在编译时进行类型检查，但不保证转换的安全性。</li></ul><pre><code class="cpp">int main() &#123;    int a = 10;    void* p = reinterpret_cast&lt;void*&gt;(&amp;a); // 编译时转换    int* q = reinterpret_cast&lt;int*&gt;(p);    return 0;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>static_cast</code>：编译时检测，适用于安全的类型转换，如基本数据类型和类层次结构。</li><li><code>dynamic_cast</code>：运行时检测，适用于多态类型转换，需要运行时类型检查。</li><li><code>const_cast</code>：编译时检测，适用于修改 <code>const</code> 或 <code>volatile</code> 属性。</li><li><code>reinterpret_cast</code>：编译时检测，适用于低级别、不安全的类型转换。</li></ul><p>了解这些类型转换运算符的用途和检测时刻，有助于在编写 C++ 程序时进行适当的类型转换，确保代码的安全性和正确性。</p><h3 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1.const_cast"></a>1.const_cast</h3><p><code>const_cast</code> 是 C++ 中的一个类型转换运算符，用于去除或添加指针或引用的常量性。与其他类型转换运算符不同，<code>const_cast</code> 只能用于修改类型的 <code>const</code> 或 <code>volatile</code> 属性。</p><h3 id="const-cast-基本语法"><a href="#const-cast-基本语法" class="headerlink" title="const_cast 基本语法"></a><code>const_cast</code> 基本语法</h3><pre><code class="cpp">const_cast&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型。</li><li><code>expression</code>：要转换的表达式。</li></ul><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><ol><li><strong>去除常量性</strong>：将 <code>const</code> 指针或引用转换为非 <code>const</code>，允许修改对象。</li><li><strong>添加常量性</strong>：将非 <code>const</code> 指针或引用转换为 <code>const</code>。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="去除常量性"><a href="#去除常量性" class="headerlink" title="去除常量性"></a>去除常量性</h4><pre><code class="cpp">int main() &#123;    const int n = 42;    // 将 const int* 转换为 int*    int* p = const_cast&lt;int*&gt;(&amp;n);        // 修改值，尽管这种修改可能导致未定义行为    *p = 24;        std::cout &lt;&lt; &quot;n: &quot; &lt;&lt; n &lt;&lt; std::endl;      return 0;&#125;</code></pre><h4 id="成员函数中去除常量性"><a href="#成员函数中去除常量性" class="headerlink" title="成员函数中去除常量性"></a>成员函数中去除常量性</h4><p>在某些情况下，成员函数被声明为 <code>const</code>，但是你需要修改成员变量。可以使用 <code>const_cast</code> 去除 <code>const</code> 属性。</p><pre><code class="cpp">class MyClass &#123;public:    MyClass(int val) : value(val) &#123;&#125;    void setValue(int val) const &#123;        // 去除 this 指针的常量性        const_cast&lt;MyClass*&gt;(this)-&gt;value = val;    &#125;    int getValue() const &#123;        return value;    &#125;private:    int value;&#125;;int main() &#123;    const MyClass obj(10);    obj.setValue(20);  // 修改常量对象的成员变量    std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; obj.getValue() &lt;&lt; std::endl;  // 输出 20    return 0;&#125;</code></pre><h4 id="与库函数的兼容性"><a href="#与库函数的兼容性" class="headerlink" title="与库函数的兼容性"></a>与库函数的兼容性</h4><p>有时你需要调用一个不接受 <code>const</code> 参数的旧库函数。你可以使用 <code>const_cast</code> 去除 <code>const</code> 属性来与这样的函数兼容。</p><pre><code class="cpp">void legacyFunction(char* str) &#123;    std::cout &lt;&lt; &quot;Legacy function: &quot; &lt;&lt; str &lt;&lt; std::endl;&#125;int main() &#123;    const char* text = &quot;Hello, world!&quot;;    // 将 const char* 转换为 char*    legacyFunction(const_cast&lt;char*&gt;(text));    return 0;&#125;</code></pre><h3 id="添加常量性"><a href="#添加常量性" class="headerlink" title="添加常量性"></a>添加常量性</h3><p>虽然不常见，但也可以使用 <code>const_cast</code> 添加常量性。</p><pre><code class="cpp">int main() &#123;    int n = 42;    // 将 int* 转换为 const int*    const int* p = const_cast&lt;const int*&gt;(&amp;n);    // 现在 p 是一个 const int*，不能通过它修改 n    // *p = 24;  // 错误，不能修改    return 0;&#125;</code></pre><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><p><strong>未定义行为</strong>：通过 <code>const_cast</code> 去除常量性并修改对象，如果对象本身是常量的（例如，定义为 <code>const</code>），这种修改会导致未定义行为。</p><pre><code class="cpp">const int n = 42;int* p = const_cast&lt;int*&gt;(&amp;n);*p = 24;  </code></pre></li><li><p><strong>设计意图</strong>：<code>const_cast</code> 应该仅用于你确定不会破坏代码逻辑和设计意图的情况下。常量性通常用于保护数据不被意外修改，因此应谨慎使用 <code>const_cast</code>。</p></li><li><p><strong>兼容性</strong>：<code>const_cast</code> 的主要用途是为了与旧的、不使用 <code>const</code> 修饰的代码或库进行兼容。在新的代码中，尽量避免使用 <code>const_cast</code>，并采用更为安全的设计。</p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>const_cast</code> 是一个功能强大的类型转换工具，用于在 C++ 中处理 <code>const</code> 和 <code>volatile</code> 属性。尽管它在某些场景下非常有用，但由于可能引发未定义行为，因此应谨慎使用，并尽量在设计时避免需要使用它的情况。</p><h3 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2.static_cast"></a>2.static_cast</h3><p><code>static_cast</code> 是 C++ 中的一种类型转换运算符，用于在编译时执行类型转换。与 <code>reinterpret_cast</code> 和 <code>const_cast</code> 不同，<code>static_cast</code> 更加安全，因为它只能在特定类型之间进行转换，并且在编译时进行检查。它适用于以下几种常见的类型转换场景：</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="cpp">static_cast&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型。</li><li><code>expression</code>：要转换的表达式。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p><strong>基本数据类型之间的转换</strong>：</p><pre><code class="cpp">int main() &#123;    float f = 3.14;    int i = static_cast&lt;int&gt;(f);  // 将 float 转换为 int    std::cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; std::endl;  // 输出 i: 3    return 0;&#125;</code></pre></li><li><p><strong>指针类型之间的转换</strong>：</p><pre><code class="cpp">class Base &#123;&#125;;class Derived : public Base &#123;&#125;;int main() &#123;    Derived d;    Base* b = static_cast&lt;Base*&gt;(&amp;d);  // 将 Derived* 转换为 Base*    return 0;&#125;</code></pre></li><li><p><strong>将空指针转换为其他指针类型</strong>：</p><pre><code class="cpp">int main() &#123;    void* ptr = nullptr;    int* intPtr = static_cast&lt;int*&gt;(ptr);  // 将 void* 转换为 int*    return 0;&#125;</code></pre></li><li><p><strong>转换枚举类型</strong>：</p><pre><code class="cpp">enum Color &#123; RED, GREEN, BLUE &#125;;int main() &#123;    Color c = RED;    int colorInt = static_cast&lt;int&gt;(c);  // 将枚举类型转换为 int    std::cout &lt;&lt; &quot;colorInt: &quot; &lt;&lt; colorInt &lt;&lt; std::endl;  // 输出 colorInt: 0    return 0;&#125;</code></pre></li><li><p><strong>基础类和派生类之间的转换</strong>：</p><pre><code class="cpp">class Base &#123;public:    virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;&#125;&#125;;int main() &#123;    Base* b = new Derived();    Derived* d = static_cast&lt;Derived*&gt;(b);  // 将 Base* 转换为 Derived*    d-&gt;derivedFunction();  // 调用派生类的方法    delete b;    return 0;&#125;</code></pre></li><li><p><strong>有意义的类型转换运算符</strong>：</p><pre><code class="cpp">class Complex &#123;public:    Complex(double real, double imag) : real(real), imag(imag) &#123;&#125;    // 定义转换运算符，将 Complex 转换为 double    operator double() const &#123;        return real;    &#125;private:    double real;    double imag;&#125;;int main() &#123;    Complex c(3.0, 4.0);    double realPart = static_cast&lt;double&gt;(c);  // 使用转换运算符将 Complex 转换为 double    std::cout &lt;&lt; &quot;realPart: &quot; &lt;&lt; realPart &lt;&lt; std::endl;  // 输出 realPart: 3.0    return 0;&#125;</code></pre></li></ol><h3 id="使用注意事项-1"><a href="#使用注意事项-1" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><p><strong>安全性</strong>：<code>static_cast</code> 进行的是编译时检查，因此相对于 <code>reinterpret_cast</code> 更为安全。但它不能用于去除 <code>const</code>、<code>volatile</code> 限定符，也不能进行不相关类型的转换。</p></li><li><p><strong>适用场景</strong>：适用于基本数据类型、指针类型、枚举类型、类层次结构中的上行转换和下行转换（必须确保安全下行）。</p></li><li><p><strong>避免未定义行为</strong>：在进行基类和派生类之间的转换时，必须确保转换是安全的，即被转换对象实际是派生类类型，否则会导致未定义行为。</p></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>static_cast</code> 是 C++ 中一种安全且常用的类型转换运算符，适用于多种类型转换场景。它在编译时进行类型检查，相比 <code>reinterpret_cast</code> 和 <code>const_cast</code> 更加安全可靠。在使用时，确保理解转换的类型和语义，以避免潜在的未定义行为。</p><p><code>dynamic_cast</code> 是 C++ 中的一种类型转换运算符，用于在运行时进行安全的类型转换。它主要用于处理继承层次结构中的指针或引用，特别是在多态（polymorphism）情况下。<code>dynamic_cast</code> 通过运行时类型检查（RTTI, Run-Time Type Information）来确保转换的安全性。如果转换失败，指针类型会返回 <code>nullptr</code>，引用类型会抛出 <code>std::bad_cast</code> 异常。</p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="cpp">dynamic_cast&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型，必须是一个指针或引用类型。</li><li><code>expression</code>：要转换的表达式，通常是一个指向基类的指针或引用。</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>向下转换（Downcasting）</strong>：将基类指针或引用转换为派生类指针或引用。</li><li><strong>横向转换（Sidecasting）</strong>：在有多重继承的情况下，从一个基类指针转换为另一个基类指针。</li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="向下转换"><a href="#向下转换" class="headerlink" title="向下转换"></a>向下转换</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base &#123;public:    virtual ~Base() &#123;&#125;  // 必须有虚函数以启用 RTTI&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;int main() &#123;    Base* basePtr = new Derived();  // 基类指针指向派生类对象    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);    if (derivedPtr) &#123;        derivedPtr-&gt;derivedFunction();  // 安全调用派生类函数    &#125; else &#123;        std::cout &lt;&lt; &quot;Conversion failed&quot; &lt;&lt; std::endl;    &#125;    delete basePtr;    return 0;&#125;</code></pre><h4 id="横向转换"><a href="#横向转换" class="headerlink" title="横向转换"></a>横向转换</h4><pre><code class="cpp">#include &lt;iostream&gt;class Base1 &#123;public:    virtual ~Base1() &#123;&#125;&#125;;class Base2 &#123;public:    virtual ~Base2() &#123;&#125;&#125;;class Derived : public Base1, public Base2 &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;int main() &#123;    Base1* base1Ptr = new Derived();  // Base1 指针指向 Derived 对象    Base2* base2Ptr = dynamic_cast&lt;Base2*&gt;(base1Ptr);    if (base2Ptr) &#123;        std::cout &lt;&lt; &quot;Successfully cast Base1* to Base2*&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;Conversion failed&quot; &lt;&lt; std::endl;    &#125;    delete base1Ptr;    return 0;&#125;</code></pre><h4 id="引用类型的转换"><a href="#引用类型的转换" class="headerlink" title="引用类型的转换"></a>引用类型的转换</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base &#123;public:    virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;void process(Base&amp; baseRef) &#123;    try &#123;        Derived&amp; derivedRef = dynamic_cast&lt;Derived&amp;&gt;(baseRef);        derivedRef.derivedFunction();    &#125; catch (const std::bad_cast&amp; e) &#123;        std::cerr &lt;&lt; &quot;Bad cast: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    Derived derivedObj;    Base&amp; baseRef = derivedObj;    process(baseRef);  // 安全转换并调用派生类方法    return 0;&#125;</code></pre><h3 id="使用注意事项-2"><a href="#使用注意事项-2" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol><li><strong>必须有虚函数</strong>：基类必须有至少一个虚函数，以便启用运行时类型信息（RTTI）。</li><li><strong>转换失败处理</strong>：在使用指针类型时，转换失败会返回 <code>nullptr</code>，在使用引用类型时，转换失败会抛出 <code>std::bad_cast</code> 异常。</li><li><strong>性能考虑</strong>：<code>dynamic_cast</code> 在运行时进行类型检查，因此相对于 <code>static_cast</code> 有一定的性能开销。</li><li><strong>避免不必要的转换</strong>：尽量设计代码避免频繁使用 <code>dynamic_cast</code>，如果可能，使用更优雅的设计模式，如策略模式或访问者模式。</li></ol><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><code>dynamic_cast</code> 是一个强大的工具，用于在 C++ 中处理继承层次结构中的类型安全转换。它通过运行时类型检查来确保转换的安全性，适用于向下转换和横向转换。理解和正确使用 <code>dynamic_cast</code> 可以帮助你编写更加健壮和安全的面向对象代码。</p><h3 id="4-reinterpret-cast-1"><a href="#4-reinterpret-cast-1" class="headerlink" title="4.reinterpret_cast"></a>4.reinterpret_cast</h3><p><code>reinterpret_cast</code> 是 C++ 中的一种类型转换运算符，用于强制转换指针、引用和其他类型之间。与其他类型转换运算符（如 <code>static_cast</code>、<code>dynamic_cast</code> 和 <code>const_cast</code>）不同，<code>reinterpret_cast</code> 可以执行非常规的类型转换，包括不安全的和未定义行为的转换，因此使用时需要特别小心。</p><h3 id="使用场景和示例"><a href="#使用场景和示例" class="headerlink" title="使用场景和示例"></a>使用场景和示例</h3><ol><li><p><strong>指针类型之间的转换</strong>：</p><pre><code class="cpp">int main() &#123;    int n = 42;    // 将 int* 转换为 char*    char* p = reinterpret_cast&lt;char*&gt;(&amp;n);    // 输出指针 p 所指向的值    std::cout &lt;&lt; *p &lt;&lt; std::endl;  // 注意：输出的值依赖于系统的字节序和类型大小    return 0;&#125;</code></pre></li><li><p><strong>将整数转换为指针类型</strong>：</p><pre><code class="cpp">int main() &#123;    intptr_t addr = 0x12345678;  // 整数地址    // 将整数转换为指针    int* p = reinterpret_cast&lt;int*&gt;(addr);    // 打印指针地址    std::cout &lt;&lt; p &lt;&lt; std::endl;    return 0;&#125;</code></pre></li><li><p><strong>将指针转换为整数类型</strong>：</p><pre><code class="cpp">int main() &#123;    int n = 42;    int* p = &amp;n;    // 将指针转换为整数    intptr_t addr = reinterpret_cast&lt;intptr_t&gt;(p);    // 打印整数地址    std::cout &lt;&lt; std::hex &lt;&lt; addr &lt;&lt; std::endl;    return 0;&#125;</code></pre></li><li><p><strong>指向对象的指针转换为指向不同类型对象的指针</strong>：</p><pre><code class="cpp">struct A &#123;    int x;&#125;;struct B &#123;    int y;&#125;;int main() &#123;    A a;    a.x = 10;    // 将 A* 转换为 B*    B* b = reinterpret_cast&lt;B*&gt;(&amp;a);    // 注意：访问 b-&gt;y 是不安全的，因为它不是 B 对象    std::cout &lt;&lt; b-&gt;y &lt;&lt; std::endl;  // 未定义行为    return 0;&#125;</code></pre></li></ol><h3 id="使用注意事项-3"><a href="#使用注意事项-3" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><strong>不安全</strong>：<code>reinterpret_cast</code> 可以执行不安全的转换，这可能导致未定义行为。</li><li><strong>可移植性</strong>：<code>reinterpret_cast</code> 的行为可能依赖于具体的编译器和平台，因此使用时要考虑代码的可移植性。</li><li><strong>用途有限</strong>：应该尽量减少使用 <code>reinterpret_cast</code>，除非确实需要进行底层的、特定的类型转换，且确定不会导致未定义行为。</li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>reinterpret_cast</code> 是一种功能强大但危险的类型转换运算符，主要用于需要底层操作的场景。使用时应确保转换是合理且安全的，以避免潜在的未定义行为和难以调试的问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++的const</title>
      <link href="/2024/08/05/c-de-const/"/>
      <url>/2024/08/05/c-de-const/</url>
      
        <content type="html"><![CDATA[<h1 id="C-const-关键字小结"><a href="#C-const-关键字小结" class="headerlink" title="C++ const 关键字小结"></a>C++ <code>const</code> 关键字小结</h1><p><code>const</code> 是 constant 的缩写，本意是不变的、不易改变的意思。在 C++ 中，</p><p><code>const</code> 用来修饰内置类型变量、自定义对象、成员函数、返回值、函数参数。</p><h2 id="1-C语言的-const-特点"><a href="#1-C语言的-const-特点" class="headerlink" title="1. C语言的 const 特点"></a>1. C语言的 <code>const</code> 特点</h2><p>const int a &#x3D; 10; &#x2F;&#x2F; 不要把a看成常量<br>&#x2F;&#x2F; a的本质是变量，只是只读变量</p><p>C语言的 <code>const</code> 修饰全局变量默认是（外部链接的）。</p><h3 id="fun-c"><a href="#fun-c" class="headerlink" title="fun.c"></a>fun.c</h3><pre><code class="cpp">// C语言的const修饰全局变量默认是（外部链接的）// 外部链接: 其他源文件可以使用const int num = 100; // 只读的全局变量，内存放在文字常量区（内存空间只读）</code></pre><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><pre><code class="cpp">// 对fun.c中的num进行声明(不要赋值)extern const int num;void test03() &#123;    printf(&quot;num = %d\n&quot;, num);    // num = 200; // err num只读    // C语言中const修饰变量名，说明变量名为只读（用户不能通过变量名data进行赋值）    const int data = 100; // 局部只读变量，内存在栈区（内存可读可写）    // data = 200; // err    printf(&quot;data = %d\n&quot;, data);    // 但是：如果知道data的地址，可以通过地址间接地修改data所对应空间的内容    int *p = (int *)&amp;data;    *p = 2000;    printf(&quot;data = %d\n&quot;, data); // ok 2000&#125;</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li><code>const</code> 修饰全局变量 <code>num</code>，变量名只读，内存空间在文字常量区（只读），不能通过 <code>num</code> 的地址修改空间内容。</li><li><code>const</code> 修饰局部变量 <code>data</code>，变量名只读，内存空间在栈区（可读可写），可以通过 <code>data</code> 地址间接地修改空间内容。</li></ol><h2 id="2-C-中的-const-深入理解"><a href="#2-C-中的-const-深入理解" class="headerlink" title="2. C++中的 const 深入理解"></a>2. C++中的 <code>const</code> 深入理解</h2><p><img src="/images/v2-cfd0b188ea87aeb4eed52737f45697b9_r.jpg"></p><h3 id="fun-cpp"><a href="#fun-cpp" class="headerlink" title="fun.cpp"></a>fun.cpp</h3><pre><code class="cpp">// const修饰的全局变量默认是内部链接（只在当前源文件有效，不能直接用于其他源文件）// const int num = 100;// 如果必须用在其他源文件使用只读的全局变量，必须加 extern 将 num 转换成外部链接extern const int num = 100;</code></pre><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><pre><code class="cpp">// 声明extern const int num;struct Person &#123;    int num;    char name[32];&#125;;void test04() &#123;    cout &lt;&lt; &quot;全局num = &quot; &lt;&lt; num &lt;&lt; endl; // err 不识别num    // 1. C++中，对于基础类型，系统不会给data开辟空间，data放到符号表中    const int data = 10;    // data = 100; // err 只读    cout &lt;&lt; &quot;data = &quot; &lt;&lt; data &lt;&lt; endl;    // 2. C++中当对data取地址的时候，系统就会给data开辟空间    int *p = (int *)&amp;data;    *p = 2000;    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; // 空间内容修改成功 2000    cout &lt;&lt; &quot;data = &quot; &lt;&lt; data &lt;&lt; endl; // data 还是10，为啥？    // 2. 当以变量的形式初始化const修饰的变量，系统会为其开辟空间    int b = 200;    const int a = b; // 系统直接为a开辟空间，而不会把a放入符号表中    p = (int *)&amp;a;    *p = 3000;    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; // 3000    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // 3000    // 3. const修饰自定义数据类型（结构体、对象），系统会分配空间    const Person per = &#123;100, &quot;lucy&quot;&#125;;    // per.num = 1000; // err    cout &lt;&lt; &quot;num = &quot; &lt;&lt; per.num &lt;&lt; &quot;, name = &quot; &lt;&lt; per.name &lt;&lt; endl; // 100 lucy    Person *p1 = (Person *)&amp;per;    p1-&gt;num = 2000;    cout &lt;&lt; &quot;num = &quot; &lt;&lt; per.num &lt;&lt; &quot;, name = &quot; &lt;&lt; per.name &lt;&lt; endl; // 2000 lucy&#125;</code></pre><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="/%5Cimages%5CSnipaste_2024-08-05_22-41-30.png"></p><p>C++的<code>const</code>总结：</p><ol><li><code>const int data = 10;</code> &#x2F;&#x2F; data先放入符号表</li><li>如果对data取地址，系统才会给data开辟空间</li><li><code>const int a = b;</code> &#x2F;&#x2F; b是变量名，系统直接给a开辟空间，而不放入符号表</li><li><code>const</code> 修饰自定义数据，系统为自定义数据开辟空间</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cmp报错</title>
      <link href="/2024/08/05/cmp-bao-cuo/"/>
      <url>/2024/08/05/cmp-bao-cuo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11智能指针</title>
      <link href="/2024/08/05/c-11-zhi-neng-zhi-zhen/"/>
      <url>/2024/08/05/c-11-zhi-neng-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h3 id="共享智能指针"><a href="#共享智能指针" class="headerlink" title="共享智能指针"></a>共享智能指针</h3><h3 id="1-shared-ptr的初始化"><a href="#1-shared-ptr的初始化" class="headerlink" title="1.shared_ptr的初始化"></a>1.shared_ptr的初始化</h3><p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针<code>shared_ptr</code> 是一个模板类，如果要进行初始化有三种方式：通过<strong>构造函数</strong>、<strong>make_shared辅助函数</strong>以及<strong>reset方法</strong>。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数<code>use_count</code>，函数原型如下：</p><pre><code class="c++">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。long use_count() const noexcept;</code></pre><h5 id="1-1-构造函数初始化"><a href="#1-1-构造函数初始化" class="headerlink" title="1.1 构造函数初始化"></a>1.1 构造函数初始化</h5><p>shared_ptr<T> 类模板中，提供了多种实用的构造函数, 语法格式如下:<br>shared_ptr<T> 智能指针名字(创建堆内存);</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存    shared_ptr&lt;int&gt; ptr1(new int(520));    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;        // 使用智能指针管理一块字符数组对应的堆内存    shared_ptr&lt;char&gt; ptr2(new char[12]);    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;        // 创建智能指针对象, 不管理任何内存    shared_ptr&lt;int&gt; ptr3;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;        // 创建智能指针对象, 初始化为空    shared_ptr&lt;int&gt; ptr4(nullptr);    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    return 0;&#125;</code></pre><p>测试代码输出的结果如下:</p><p>ptr1管理的内存引用计数: 1<br>ptr2管理的内存引用计数: 1<br>ptr3管理的内存引用计数: 0<br>ptr4管理的内存引用计数: 0</p><p>如果智能指针被初始化了一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为<code>nullptr</code>空指针，引用计数不会+1。另外，不要使用一个原始指针初始化多个<code>shared_ptr</code>。</p><pre><code class="c++">int *p = new int;shared_ptr&lt;int&gt; p1(p);    //原始指针只能吃初始化一个智能指针shared_ptr&lt;int&gt; p2(p);// error, 编译不会报错, 运行会出错</code></pre><h5 id="1-2-通过拷贝和移动构造函数初始化"><a href="#1-2-通过拷贝和移动构造函数初始化" class="headerlink" title="1.2 通过拷贝和移动构造函数初始化"></a>1.2 通过拷贝和移动构造函数初始化</h5><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1    shared_ptr&lt;int&gt; ptr1(new int(520));    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;        //调用拷贝构造函数    shared_ptr&lt;int&gt; ptr2(ptr1);    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    shared_ptr&lt;int&gt; ptr3 = ptr1;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;        //调用移动构造函数    shared_ptr&lt;int&gt; ptr4(move(ptr1));    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    std::shared_ptr&lt;int&gt; ptr5 = move(ptr2);    cout &lt;&lt; &quot;ptr5管理的内存引用计数: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;        return 0;&#125;</code></pre><p>测试程序输入的结果：<br>ptr1管理的内存引用计数: 1<br>ptr2管理的内存引用计数: 2<br>ptr3管理的内存引用计数: 3<br>ptr4管理的内存引用计数: 3<br>ptr5管理的内存引用计数: 3</p><p>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。</p><h5 id="1-3-通过make-shared初始化"><a href="#1-3-通过make-shared初始化" class="headerlink" title="1.3 通过make_shared初始化"></a>1.3 通过make_shared初始化</h5><p>通过C++提供的make_shared() 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p><pre><code class="c++">template&lt; class T, class... Args &gt;shared_ptr&lt;T&gt; make_shared( Args&amp;&amp;... args );//T：模板参数的数据类型//Args&amp;&amp;... args ：要初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定</code></pre><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;class Test&#123;public:    Test()     &#123;        cout &lt;&lt; &quot;construct Test...&quot; &lt;&lt; endl;    &#125;    Test(int x)     &#123;        cout &lt;&lt; &quot;construct Test, x = &quot; &lt;&lt; x &lt;&lt; endl;    &#125;    Test(string str)     &#123;        cout &lt;&lt; &quot;construct Test, str = &quot; &lt;&lt; str &lt;&lt; endl;    &#125;    ~Test()    &#123;        cout &lt;&lt; &quot;destruct Test ...&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1    shared_ptr&lt;int&gt; ptr1 = make_shared&lt;int&gt;(520);    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;    shared_ptr&lt;Test&gt; ptr2 = make_shared&lt;Test&gt;();    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    shared_ptr&lt;Test&gt; ptr3 = make_shared&lt;Test&gt;(520);    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;    shared_ptr&lt;Test&gt; ptr4 = make_shared&lt;Test&gt;(&quot;我是要成为海贼王的男人!!!&quot;);    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    return 0;&#125;</code></pre><p>使用std::make_shared()模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。</p><h5 id="1-4-通过-reset方法初始化"><a href="#1-4-通过-reset方法初始化" class="headerlink" title="1.4 通过 reset方法初始化"></a>1.4 通过 reset方法初始化</h5><p>共享智能指针类提供的std::shared_ptr::reset方法函数原型如下：</p><pre><code class="c++">void reset() noexcept;template&lt; class Y &gt;void reset( Y* ptr );template&lt; class Y, class Deleter &gt;void reset( Y* ptr, Deleter d );template&lt; class Y, class Deleter, class Alloc &gt;void reset( Y* ptr, Deleter d, Alloc alloc );</code></pre><p>ptr：指向要取得所有权的对象的指针<br>d：指向要取得所有权的对象的指针<br>aloc：内部存储所用的分配器</p><p>测试代码如下：</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1    shared_ptr&lt;int&gt; ptr1 = make_shared&lt;int&gt;(520);    shared_ptr&lt;int&gt; ptr2 = ptr1;    shared_ptr&lt;int&gt; ptr3 = ptr1;    shared_ptr&lt;int&gt; ptr4 = ptr1;    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    ptr4.reset();    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;        shared_ptr&lt;int&gt; ptr5;    ptr5.reset(new int(250));    cout &lt;&lt; &quot;ptr5管理的内存引用计数: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;        return 0;&#125;</code></pre><p>测试代码输入的结果:</p><p>ptr1管理的内存引用计数: 4<br>ptr2管理的内存引用计数: 4<br>ptr3管理的内存引用计数: 4<br>ptr4管理的内存引用计数: 4</p><p>ptr1管理的内存引用计数: 3<br>ptr2管理的内存引用计数: 3<br>ptr3管理的内存引用计数: 3<br>ptr4管理的内存引用计数: 0</p><p>ptr5管理的内存引用计数: 1</p><p><strong>对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。</strong></p><h5 id="1-5-获取原始指针"><a href="#1-5-获取原始指针" class="headerlink" title="1.5 获取原始指针"></a>1.5 获取原始指针</h5><p>通过智能指针可以管理一个普通变量或者对象的地址，此时原始地址就不可见了。当我们想要修改变量或者对象中的值的时候，就需要从智能指针对象中先取出数据的原始内存的地址再操作，解决方案是调用共享智能指针类提供的get()方法，其函数原型如下：</p><p><code>T* get() const noexcept;</code></p><p>测试代码如下:</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    int len = 128;    shared_ptr&lt;char&gt; ptr(new char[len]);        // 得到指针的原始地址    char* add = ptr.get();    memset(add, 0, len);    strcpy(add, &quot;我是要成为海贼王的男人!!!&quot;);    cout &lt;&lt; &quot;string: &quot; &lt;&lt; add &lt;&lt; endl;        shared_ptr&lt;int&gt; p(new int);    *p = 100;    cout &lt;&lt; *p.get() &lt;&lt; &quot;  &quot; &lt;&lt; *p &lt;&lt; endl;        return 0;&#125;</code></pre><h3 id="指定删除器"><a href="#指定删除器" class="headerlink" title="指定删除器"></a>指定删除器</h3><p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;// 自定义删除器函数，释放int型内存void deleteIntPtr(int* p)&#123;    delete p;    cout &lt;&lt; &quot;int 型内存被释放了...&quot;;&#125;int main()&#123;    shared_ptr&lt;int&gt; ptr(new int(250), deleteIntPtr);    return 0;&#125;//删除器函数也可以是lambda表达式，因此代码也可以写成下面这样：int main()&#123;    shared_ptr&lt;int&gt; ptr(new int(250), [](int* p) &#123;delete p; &#125;);    return 0;&#125;</code></pre><p>在上面的代码中，lambda表达式的参数就是智能指针管理的内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。</p><p>在C++11中使用<code>shared_ptr</code>管理动态数组时，需要指定删除器，因为<code>shared_ptr</code>的<em>默认删除器不支持数组对象</em>，具体的处理代码如下：</p><pre><code class="c++">int main()&#123;    shared_ptr&lt;int&gt; ptr(new int[10], [](int* p) &#123;delete[]p; &#125;);    return 0;&#125;/*在删除数组内存时，除了自己编写删除器，也可以使用C++提供的default_delete&lt;T&gt;()函数作为删除器，这个函数内部的删除功能也是通过调用delete来实现的，要释放什么类型的内存就将模板类型T指定为什么类型即可。具体处理代码如下：*/int main()&#123;    shared_ptr&lt;int&gt; ptr(new int[10], default_delete&lt;int[]&gt;());    return 0;&#125;</code></pre><p>另外，我们还可以自己封装一个<code>make_shared_array</code>方法来让<code>shared_ptr</code>支持数组，代码如下:</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;template &lt;typename T&gt;shared_ptr&lt;T&gt; make_share_array(size_t size)&#123;    // 返回匿名对象    return shared_ptr&lt;T&gt;(new T[size], default_delete&lt;T[]&gt;());&#125;int main()&#123;    shared_ptr&lt;int&gt; ptr1 = make_share_array&lt;int&gt;(10);    cout &lt;&lt; ptr1.use_count() &lt;&lt; endl;    shared_ptr&lt;char&gt; ptr2 = make_share_array&lt;char&gt;(128);    cout &lt;&lt; ptr2.use_count() &lt;&lt; endl;    return 0;&#125;</code></pre><p><code>shared_ptr</code>使用注意事项:</p><p>1.不能使用一个原始地址初始化多个共享智能指针。</p><p>2.函数不能返回管理了this的共享智能指针对象。</p><p>3.共享智能指针不能循环引用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消息验证码和数字签名</title>
      <link href="/2024/07/29/xiao-xi-yan-zheng-ma-he-shu-zi-qian-ming/"/>
      <url>/2024/07/29/xiao-xi-yan-zheng-ma-he-shu-zi-qian-ming/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/07/29/she-ji-mo-shi/"/>
      <url>/2024/07/29/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<p><strong>工厂设计模式</strong></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std; // 引入 std 命名空间// 抽象产品类class Product &#123;public:    virtual void display() = 0;    virtual ~Product() &#123;&#125;&#125;;// 具体产品类 Aclass ConcreteProductA : public Product &#123;public:    void display() override &#123;        cout &lt;&lt; &quot;Concrete Product A&quot; &lt;&lt; endl;    &#125;&#125;;// 具体产品类 Bclass ConcreteProductB : public Product &#123;public:    void display() override &#123;        cout &lt;&lt; &quot;Concrete Product B&quot; &lt;&lt; endl;    &#125;&#125;;// 工厂类class Factory &#123;public:    // 静态方法，根据参数创建具体产品对象    static unique_ptr&lt;Product&gt; createProduct(char type) &#123;        switch (type) &#123;            case &#39;A&#39;:                return make_unique&lt;ConcreteProductA&gt;();            case &#39;B&#39;:                return make_unique&lt;ConcreteProductB&gt;();            default:                return nullptr;        &#125;    &#125;&#125;;int main() &#123;    // 使用工厂创建具体产品 A    unique_ptr&lt;Product&gt; productA = Factory::createProduct(&#39;A&#39;);    if (productA) &#123;        productA-&gt;display();    &#125;    // 使用工厂创建具体产品 B    unique_ptr&lt;Product&gt; productB = Factory::createProduct(&#39;B&#39;);    if (productB) &#123;        productB-&gt;display();    &#125;    // 使用工厂创建不存在的产品    unique_ptr&lt;Product&gt; productC = Factory::createProduct(&#39;C&#39;);    if (!productC) &#123;        cout &lt;&lt; &quot;Invalid product type requested.&quot; &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux配置环境变量</title>
      <link href="/2024/07/26/linux-pei-zhi-huan-jing-bian-liang/"/>
      <url>/2024/07/26/linux-pei-zhi-huan-jing-bian-liang/</url>
      
        <content type="html"><![CDATA[<p>当你在终端中输入 <code>echo $PATH</code> 并按回车，你会看到一系列由冒号分隔的目录路径。<code>$PATH</code> 是一个环境变量，它告诉你的系统在哪里查找可执行命令。每当你在终端输入一个命令，系统就会在 <code>$PATH</code> 变量列出的目录中搜索对应的可执行文件。</p><p><code>$PATH</code> 变量的值通常包括以下目录：</p><ul><li><code>/usr/local/bin</code>: 用户安装的本地应用程序的可执行文件。</li><li><code>/usr/bin</code>: 系统提供的标准应用程序。</li><li><code>/bin</code>: 基础的系统命令。</li><li><code>/usr/sbin</code>: 系统管理员使用的系统命令。</li><li><code>/sbin</code>: 基础的系统管理命令。</li><li><code>~/bin</code>: 用户个人的可执行文件目录。</li><li><code>/usr/local/sbin</code>: 类似于 <code>/usr/local/bin</code>，但用于系统管理命令。</li></ul><p>例如，<code>$PATH</code> 的输出可能类似于：</p><p><strong>&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:~&#x2F;bin</strong></p><p>这意味着当你在终端中输入 <code>ls</code>、<code>cd</code> 或任何其他命令时，系统会在这些目录中查找匹配的可执行文件。</p><p>你可以通过以下步骤将 &#x2F;usr&#x2F;local&#x2F;lib 添加到 PATH 环境变量中：<br>打开终端。<br>使用以下命令将 &#x2F;usr&#x2F;local&#x2F;lib 添加到当前会话的 PATH 环境变量：<br><code>export PATH=$PATH:/usr/local/lib</code><br>这只会在当前终端会话中生效。如果你关闭终端，设置将会丢失。</p><p>如果你希望永久性地将 &#x2F;usr&#x2F;local&#x2F;lib 添加到 PATH 环境变量中，你需要将上述命令添加到你的 shell 配置文件中。具体步骤如下：<br>对于 bash，编辑 ~&#x2F;.bashrc 文件：<br><code>echo &#39;export PATH=$PATH:/usr/local/lib&#39; &gt;&gt; ~/.bashrc</code></p><p>使配置文件生效：</p><p><code>source ~/.bashrc</code></p><p>这样，&#x2F;usr&#x2F;local&#x2F;lib 将被永久添加到 PATH 环境变量中，并在你每次打开新的终端会话时生效。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11线程库</title>
      <link href="/2024/05/06/c-11-xian-cheng-ku/"/>
      <url>/2024/05/06/c-11-xian-cheng-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="1-std-thread"><a href="#1-std-thread" class="headerlink" title="1. std::thread"></a>1. <code>std::thread</code></h2><p><code>std::thread</code> 类用于创建和管理线程。每个 <code>std::thread</code> 对象表示一个线程，能够执行任何可调用的对象。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ul><li><p><strong>构造函数</strong>：创建线程并执行指定的函数或可调用对象。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;void print_message(const std::string&amp; message) &#123;    std::cout &lt;&lt; message &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t(print_message, &quot;Hello from thread!&quot;); // 创建线程并传递参数    t.join(); // 等待线程完成    return 0;&#125;</code></pre></li><li><p>**<code>join()</code> 和 <code>detach()</code>**：</p><ul><li>**<code>join()</code>**：等待线程执行完成。主线程会阻塞，直到 <code>join()</code> 的线程完成。</li><li>**<code>detach()</code>**：将线程分离，让它在后台继续运行，不会阻塞主线程。如果线程对象超出作用域，分离线程的资源会被自动释放，但主线程不会等待它完成。</li></ul><pre><code class="cpp">std::thread t(print_message, &quot;Hello from detached thread!&quot;);t.detach(); // 让线程在后台运行</code></pre></li></ul><h2 id="2-std-this-thread"><a href="#2-std-this-thread" class="headerlink" title="2. std::this_thread"></a>2. <code>std::this_thread</code></h2><p><code>std::this_thread</code> 提供了与当前线程相关的功能。</p><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><ul><li><p>**<code>std::this_thread::sleep_for()</code>**：让当前线程休眠指定的时间段。</p><pre><code class="cpp">#include &lt;thread&gt;#include &lt;chrono&gt;int main() &#123;    std::this_thread::sleep_for(std::chrono::seconds(2)); // 休眠 2 秒    return 0;&#125;</code></pre></li><li><p>**<code>std::this_thread::sleep_until()</code>**：让当前线程休眠直到指定的时间点。</p><pre><code class="cpp">#include &lt;thread&gt;#include &lt;chrono&gt;int main() &#123;    auto wake_up_time = std::chrono::steady_clock::now() + std::chrono::seconds(2);    std::this_thread::sleep_until(wake_up_time); // 休眠直到指定时间点    return 0;&#125;</code></pre></li><li><p>**<code>std::this_thread::get_id()</code>**：获取当前线程的 ID。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;int main() &#123;    std::cout &lt;&lt; &quot;Current thread ID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;    return 0;&#125;</code></pre></li></ul><ul><li><p><code>std::this_thread::yield()</code> 是 C++11 引入的一种函数，用于在多线程程序中使当前线程自愿让出 CPU 时间，以便其他线程可以执行。这是一个简洁而有效的方法，用于实现线程的协作和调度，尤其是在涉及线程优先级和负载均衡时。</p><h4 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h4><pre><code class="cpp">#include &lt;thread&gt;void yield();</code></pre><ul><li>**<code>std::this_thread::yield()</code>**：使当前线程让出 CPU 时间，将其从运行状态转变为就绪状态，让调度器有机会安排其他线程运行。</li></ul><h4 id="2-工作机制"><a href="#2-工作机制" class="headerlink" title="2. 工作机制"></a>2. 工作机制</h4><ul><li><p><strong>让出 CPU</strong>：调用 <code>std::this_thread::yield()</code> 让当前线程放弃它的剩余时间片，从而允许其他线程（包括优先级较高的线程或同等优先级的线程）获得 CPU 时间。线程在调用 <code>yield</code> 后会回到就绪队列等待重新调度。</p></li><li><p><strong>调度行为</strong>：<code>yield</code> 的具体行为依赖于操作系统和线程调度策略。在某些操作系统中，<code>yield</code> 可能不会立即让当前线程放弃 CPU 时间，而是在当前时间片结束时调度其他线程。在其他系统中，<code>yield</code> 可能会更快地将当前线程移到就绪队列中。</p></li></ul><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h4><ul><li><p><strong>避免忙等待</strong>：在某些多线程应用中，线程可能需要等待某些条件的改变。在这种情况下，使用 <code>std::this_thread::yield()</code> 可以避免忙等待（即不断循环检查条件），从而降低 CPU 使用率并允许其他线程运行。</p></li><li><p><strong>线程协作</strong>：当线程间需要协调工作时，<code>yield</code> 可以让线程主动让出控制权，从而允许其他线程执行某些操作，尤其是在没有严格的优先级要求时。</p></li><li><p><strong>测试和调试</strong>：在调试多线程应用时，<code>yield</code> 可以帮助模拟不同的线程调度情况，观察系统的行为和性能。</p></li></ul><h4 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h4><p>下面的示例展示了如何使用 <code>std::this_thread::yield</code> 来实现简单的线程协作：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;atomic&gt;std::atomic&lt;bool&gt; flag&#123;false&#125;;void thread1() &#123;    while (!flag.load()) &#123;        std::this_thread::yield(); // 让出 CPU 时间    &#125;    std::cout &lt;&lt; &quot;Thread 1 finished&quot; &lt;&lt; std::endl;&#125;void thread2() &#123;    std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟工作    flag.store(true);    std::cout &lt;&lt; &quot;Thread 2 finished&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(thread1);    std::thread t2(thread2);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>在这个示例中：</p><ul><li><code>thread1</code> 线程会在 <code>flag</code> 为 <code>false</code> 时不断调用 <code>std::this_thread::yield()</code>，让出 CPU 时间。</li><li><code>thread2</code> 线程在睡眠一秒后设置 <code>flag</code> 为 <code>true</code>，使 <code>thread1</code> 能够继续执行。</li></ul><h4 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h4><ul><li><p><strong>性能影响</strong>：<code>yield</code> 的使用可能会影响性能，特别是在高负载或高频率调用时。需要在合适的场景下使用，以避免不必要的性能开销。</p></li><li><p><strong>操作系统依赖</strong>：<code>yield</code> 的行为依赖于底层操作系统的线程调度实现，因此不同操作系统可能会有不同的行为表现。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>std::this_thread::yield</code> 是一个用于线程协作和调度的有用工具，使当前线程主动让出 CPU 时间，从而允许其他线程执行。它在多线程程序中能够有效地避免忙等待、实现线程协作，并帮助调试和测试。正确使用 <code>yield</code> 可以提高线程间的协调性，但也需要注意它对性能的潜在影响。</p></li></ul><h2 id="3-std-future-和-std-promise"><a href="#3-std-future-和-std-promise" class="headerlink" title="3. std::future 和 std::promise"></a>3. <code>std::future</code> 和 <code>std::promise</code></h2><p><code>std::future</code> 和 <code>std::promise</code> 用于异步操作的结果传递和同步。</p><h3 id="std-promise-和-std-future"><a href="#std-promise-和-std-future" class="headerlink" title="std::promise 和 std::future"></a><code>std::promise</code> 和 <code>std::future</code></h3><ul><li><p>**<code>std::promise</code>**：用于设置一个值或异常，供其他线程通过 <code>std::future</code> 获取。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;void produce(std::promise&lt;int&gt;&amp;&amp; prom) &#123;    std::this_thread::sleep_for(std::chrono::seconds(1));    prom.set_value(42); // 设置结果值&#125;int main() &#123;    std::promise&lt;int&gt; prom;    std::future&lt;int&gt; fut = prom.get_future(); // 获取 future 对象    std::thread t(produce, std::move(prom)); // 将 promise 移动到线程    std::cout &lt;&lt; &quot;Waiting for result...&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl; // 获取结果    t.join();    return 0;&#125;</code></pre></li></ul><p>这段代码演示了如何使用 <code>std::promise</code> 和 <code>std::future</code> 在多线程程序中传递结果。以下是对这段代码的详细解释：</p><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol><li><p><strong>创建 <code>std::promise</code> 对象</strong></p><pre><code class="cpp">std::promise&lt;int&gt; prom;</code></pre><p><code>std::promise&lt;int&gt;</code> 用于在线程之间传递结果。它允许一个线程设置一个值，另一个线程获取这个值。</p></li><li><p><strong>获取 <code>std::future</code> 对象</strong></p><pre><code class="cpp">std::future&lt;int&gt; fut = prom.get_future();</code></pre><p>从 <code>std::promise</code> 对象中获取 <code>std::future</code> 对象。<code>std::future</code> 用于异步获取 <code>std::promise</code> 设置的值。</p></li><li><p><strong>将 <code>std::promise</code> 移动到线程中</strong></p><pre><code class="cpp">std::thread t(produce, std::move(prom));</code></pre><p><code>std::promise</code> 对象通过 <code>std::move</code> 被移动到新线程中执行。移动是必须的，因为 <code>std::promise</code> 对象在线程间传递时不支持拷贝。</p></li><li><p><strong>在新线程中设置值</strong></p><pre><code class="cpp">void produce(std::promise&lt;int&gt;&amp;&amp; prom) &#123;    std::this_thread::sleep_for(std::chrono::seconds(1));    prom.set_value(42);&#125;</code></pre><p><code>produce</code> 函数模拟一个耗时操作（通过 <code>std::this_thread::sleep_for</code>），然后使用 <code>prom.set_value(42)</code> 设置 <code>std::promise</code> 的值。这个值将被传递到 <code>std::future</code> 中。</p></li><li><p><strong>获取结果并输出</strong></p><pre><code class="cpp">std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl;</code></pre><p><code>fut.get()</code> 阻塞当前线程，直到 <code>std::promise</code> 设置的值可用。<code>fut.get()</code> 返回这个值，并输出到控制台。</p></li><li><p><strong>等待线程完成</strong></p><pre><code class="cpp">t.join();</code></pre><p><code>t.join()</code> 等待 <code>produce</code> 线程完成执行，确保程序在退出前 <code>produce</code> 线程已经执行完毕。</p></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这段代码演示了如何使用 <code>std::promise</code> 和 <code>std::future</code> 来实现线程间的结果传递：</p><ul><li><code>std::promise</code> 用于设置一个值。</li><li><code>std::future</code> 用于获取这个值。</li><li>通过 <code>std::move</code> 将 <code>std::promise</code> 移动到线程中进行设置。</li><li>使用 <code>fut.get()</code> 获取结果并输出。</li></ul><p>这种方式在处理异步操作和线程间的结果传递时非常有用。</p><ul><li><p>**<code>std::future</code>**：用于获取异步操作的结果。可以通过 <code>get()</code> 方法获取结果，或者使用 <code>wait()</code> 和 <code>wait_for()</code> 等方法等待结果的到来。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;int compute_value() &#123;    std::this_thread::sleep_for(std::chrono::seconds(1));    return 42;&#125;int main() &#123;    std::future&lt;int&gt; fut = std::async(std::launch::async, compute_value); // 异步计算    std::cout &lt;&lt; &quot;Waiting for result...&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl; // 获取结果    return 0;&#125;</code></pre></li></ul><h2 id="4-std-async"><a href="#4-std-async" class="headerlink" title="4. std::async"></a>4. <code>std::async</code></h2><p><code>std::async</code> 用于启动一个异步任务并返回 <code>std::future</code> 对象，可以用于获取异步操作的结果。</p><h3 id="使用-std-async"><a href="#使用-std-async" class="headerlink" title="使用 std::async"></a>使用 <code>std::async</code></h3><ul><li><p>**<code>std::launch::async</code>**：强制异步执行。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;int compute_value() &#123;    std::this_thread::sleep_for(std::chrono::seconds(1));    return 42;&#125;int main() &#123;    std::future&lt;int&gt; fut = std::async(std::launch::async, compute_value); // 异步计算    std::cout &lt;&lt; &quot;Waiting for result...&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl; // 获取结果    return 0;&#125;</code></pre><p>这段代码演示了如何在 C++ 中让程序在后台异步地执行任务，并在稍后的时间获取任务的结果。我们将任务分配给一个后台线程去处理，而主线程则可以继续执行其他操作。</p><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>定义任务</strong></p><pre><code class="cpp">int compute_value() &#123;    std::this_thread::sleep_for(std::chrono::seconds(1));    return 42;&#125;</code></pre><ul><li>这里定义了一个函数 <code>compute_value</code>，它模拟一个耗时的计算过程。函数内部使用 <code>std::this_thread::sleep_for</code> 暂停 1 秒钟，然后返回一个固定的结果 <code>42</code>。</li></ul></li><li><p><strong>启动异步任务</strong></p><pre><code class="cpp">std::future&lt;int&gt; fut = std::async(std::launch::async, compute_value);</code></pre><ul><li>这一行代码的作用是启动一个异步任务。<code>std::async</code> 函数会创建一个后台线程来执行 <code>compute_value</code> 函数。这意味着 <code>compute_value</code> 函数会在后台运行，而不会阻塞主线程。</li><li><code>std::future&lt;int&gt; fut</code> 是用来接收这个任务的结果的。它提供了一个机制来检查任务是否完成，并获取计算结果。</li></ul></li><li><p><strong>继续执行其他操作</strong></p><pre><code class="cpp">std::cout &lt;&lt; &quot;Waiting for result...&quot; &lt;&lt; std::endl;</code></pre><ul><li>在任务运行时，主线程会继续执行其他操作。在这个例子中，它输出一条消息，表明程序正在等待计算结果。</li></ul></li><li><p><strong>获取并显示结果</strong></p><pre><code class="cpp">std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl;</code></pre><ul><li><code>fut.get()</code> 会阻塞主线程，直到后台任务完成并返回结果。它从后台线程获取计算结果并输出。</li><li>由于 <code>compute_value</code> 函数总是返回 <code>42</code>，所以这里输出的结果是 <code>42</code>。</li></ul></li><li><p><strong>结束程序</strong></p><pre><code class="cpp">return 0;</code></pre><ul><li>程序的主函数结束，返回 <code>0</code> 表示程序成功执行。</li></ul></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>异步任务</strong>：使用 <code>std::async</code> 启动一个后台线程来执行计算任务。</li><li><strong>获取结果</strong>：通过 <code>std::future</code> 对象 <code>fut</code> 获取异步计算的结果。</li><li><strong>主线程</strong>：在后台线程执行任务时，主线程可以继续进行其他操作。</li></ul><p>这样，你的程序可以同时进行计算和执行其他操作，提高了效率和响应性。</p></li><li><p>**<code>std::launch::deferred</code>**：推迟执行，直到 <code>get()</code> 或 <code>wait()</code> 被调用。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;int compute_value() &#123;    std::cout &lt;&lt; &quot;Computing...&quot; &lt;&lt; std::endl;    return 42;&#125;int main() &#123;    std::future&lt;int&gt; fut = std::async(std::launch::deferred, compute_value); // 推迟执行    std::cout &lt;&lt; &quot;Waiting for result...&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl; // 执行并获取结果    return 0;&#125;</code></pre></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><p><strong>执行时机</strong></p><ul><li><p><strong><code>std::launch::async</code></strong>: </p><ul><li>使用 <code>std::launch::async</code> 启动的任务会立即在一个新的线程中异步执行。</li><li>任务会在后台线程中运行，主线程可以继续执行其他操作，直到任务完成或被 <code>fut.get()</code> 阻塞等待结果。</li><li>在上述代码中，<code>compute_value</code> 会在后台线程中运行，主线程会立即输出 <code>&quot;Waiting for result...&quot;</code>。</li></ul></li><li><p><strong><code>std::launch::deferred</code></strong>:</p><ul><li>使用 <code>std::launch::deferred</code> 启动的任务会被推迟到调用 <code>fut.get()</code> 时才执行。</li><li>任务不会在后台线程中立即执行，而是在调用 <code>fut.get()</code> 时在主线程中执行。</li><li>在上述代码中，主线程首先输出 <code>&quot;Waiting for result...&quot;</code>，然后调用 <code>fut.get()</code> 时才开始执行 <code>compute_value</code>，并输出 <code>&quot;Computing...&quot;</code>。</li></ul></li></ul></li><li><p><strong>线程使用</strong></p><ul><li><p><strong><code>std::launch::async</code></strong>:</p><ul><li>使用新的线程来执行任务，可能会使用额外的线程资源和上下文切换开销。</li></ul></li><li><p><strong><code>std::launch::deferred</code></strong>:</p><ul><li>不会创建新线程，任务在调用 <code>fut.get()</code> 时由当前线程（主线程）执行，这样可以节省线程创建的开销。</li></ul></li></ul></li><li><p><strong>适用场景</strong></p><ul><li><p><strong><code>std::launch::async</code></strong>:</p><ul><li>适用于需要并行处理、后台计算或需要更高响应性场景。任务在后台线程中运行，可以充分利用多核处理器的优势。</li></ul></li><li><p><strong><code>std::launch::deferred</code></strong>:</p><ul><li>适用于任务可能不一定需要执行的情况，或者希望延迟任务执行直到需要结果时。避免了不必要的计算开销。</li></ul></li></ul></li></ol><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>**<code>std::launch::async</code>**：立即在后台线程中异步执行任务，适用于需要并发计算的情况。</li><li>**<code>std::launch::deferred</code>**：推迟任务执行，直到调用 <code>fut.get()</code> 时才执行，适用于计算可能不一定需要的情况或希望延迟计算的场景。</li></ul><p>这两个选项提供了不同的任务执行策略，可以根据实际需求选择合适的方式来优化程序的性能和资源使用。</p><h4 id="std-thread-和-std-async区别："><a href="#std-thread-和-std-async区别：" class="headerlink" title="std::thread 和 std::async区别："></a><code>std::thread</code> 和 <code>std::async</code>区别：</h4><p><code>std::thread</code> 和 <code>std::async</code> 是 C++11 中用于并发编程的两种不同工具，它们在使用方式和适用场景上有一些重要区别。下面详细比较这两者的区别：</p><h3 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a><code>std::thread</code></h3><ul><li><p><strong>用法</strong>: 用于直接创建和管理线程。</p></li><li><p><strong>创建线程</strong>: 通过构造 <code>std::thread</code> 对象并传递一个可调用对象（如函数、函数对象或 Lambda 表达式）来创建线程。</p></li><li><p><strong>控制线程</strong>: 需要手动管理线程的生命周期，包括启动、同步（例如使用 <code>join()</code>）和终止。</p></li><li><p><strong>线程间通信</strong>: 通常需要使用其他同步机制（如互斥量、条件变量）来处理线程间的通信和数据共享。</p></li><li><p><strong>示例</strong>:</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;void print_message() &#123;    std::cout &lt;&lt; &quot;Hello from thread!&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t(print_message); // 创建并启动线程    t.join(); // 等待线程完成    return 0;&#125;</code></pre></li></ul><h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a><code>std::async</code></h3><ul><li><p><strong>用法</strong>: 用于启动异步任务，自动管理线程的生命周期。</p></li><li><p><strong>启动任务</strong>: 通过调用 <code>std::async</code> 来异步执行一个任务。可以指定任务的启动策略（如 <code>std::launch::async</code> 或 <code>std::launch::deferred</code>）。</p></li><li><p><strong>结果管理</strong>: <code>std::async</code> 返回一个 <code>std::future</code> 对象，可以用来获取异步计算的结果或处理任务完成的状态。</p></li><li><p><strong>线程间通信</strong>: <code>std::future</code> 提供了一种简单的方式来等待任务结果，并进行线程间的同步，避免了手动管理线程。</p></li><li><p><strong>示例</strong>:</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;future&gt;int compute_value() &#123;    return 42;&#125;int main() &#123;    std::future&lt;int&gt; fut = std::async(std::launch::async, compute_value); // 异步计算    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl; // 获取结果    return 0;&#125;</code></pre></li></ul><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ol><li><p><strong>线程管理</strong></p><ul><li><strong><code>std::thread</code></strong>: 需要手动管理线程的创建和同步（例如使用 <code>join()</code> 确保线程完成）。你直接控制线程的生命周期和行为。</li><li><strong><code>std::async</code></strong>: 由系统自动管理线程的生命周期。你只需关注任务的提交和结果获取。任务的执行和线程的管理是透明的，减少了直接线程管理的复杂性。</li></ul></li><li><p><strong>结果获取</strong></p><ul><li><strong><code>std::thread</code></strong>: 需要通过共享变量、互斥量等机制来进行线程间的数据传递和结果获取，通常需要更多的代码和同步机制。</li><li><strong><code>std::async</code></strong>: 提供了 <code>std::future</code> 对象，通过 <code>get()</code> 方法可以方便地获取计算结果，减少了线程间同步的复杂性。</li></ul></li><li><p><strong>启动策略</strong></p><ul><li><strong><code>std::thread</code></strong>: 线程一经创建便立即执行。</li><li><strong><code>std::async</code></strong>: 允许指定启动策略。可以选择立即在后台线程中执行（<code>std::launch::async</code>），或推迟到调用 <code>get()</code> 时才执行（<code>std::launch::deferred</code>）。</li></ul></li><li><p><strong>适用场景</strong></p><ul><li><strong><code>std::thread</code></strong>: 适用于需要手动控制线程行为、需要直接与线程交互的场景。适合那些线程管理逻辑复杂的应用。</li><li><strong><code>std::async</code></strong>: 适用于需要简化异步任务管理和结果获取的场景。特别适合那些希望以简单方式执行并获取结果的任务。</li></ul></li></ol><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>std::thread</code></strong> 提供了对线程创建和管理的直接控制，适用于需要复杂线程操作的情况。</li><li><strong><code>std::async</code></strong> 提供了一个更高级的接口来简化异步任务的执行和结果获取，适合需要异步计算但不希望直接管理线程的场景。</li></ul><h2 id="5-std-atomic"><a href="#5-std-atomic" class="headerlink" title="5. std::atomic"></a>5. <code>std::atomic</code></h2><p><code>std::atomic</code> 提供原子操作，用于处理共享数据时避免数据竞争。适用于基本数据类型，如 <code>int</code>、<code>bool</code> 等。</p><h3 id="使用-std-atomic"><a href="#使用-std-atomic" class="headerlink" title="使用 std::atomic"></a>使用 <code>std::atomic</code></h3><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;std::atomic&lt;int&gt; counter(0);void increment() &#123;    for (int i = 0; i &lt; 1000; ++i) &#123;        ++counter; // 原子操作，避免数据竞争    &#125;&#125;int main() &#123;    std::thread t1(increment);    std::thread t2(increment);    t1.join();    t2.join();    std::cout &lt;&lt; &quot;Counter: &quot; &lt;&lt; counter &lt;&lt; std::endl;    return 0;&#125;</code></pre><h3 id="原子操作的常用方法"><a href="#原子操作的常用方法" class="headerlink" title="原子操作的常用方法"></a>原子操作的常用方法</h3><ul><li>**<code>store()</code>**：设置值。</li><li>**<code>load()</code>**：获取值。</li><li>**<code>fetch_add()</code><strong>、</strong><code>fetch_sub()</code>**：原子性加法和减法。</li><li>**<code>compare_exchange_weak()</code><strong>、</strong><code>compare_exchange_strong()</code>**：原子比较和交换操作。</li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>C++11 的线程库引入了多个功能强大的组件来支持多线程编程：</p><ul><li>**<code>std::thread</code>**：创建和管理线程。</li><li>**<code>std::this_thread</code>**：提供与当前线程相关的功能，如休眠和获取线程 ID。</li><li>**<code>std::future</code> 和 <code>std::promise</code>**：用于异步操作的结果传递和同步。</li><li>**<code>std::async</code>**：启动异步任务并返回 <code>std::future</code> 对象。</li><li>**<code>std::atomic</code>**：提供原子操作，处理多线程中的基本数据类型。</li></ul><p>这些工具和类使得 C++11 在处理并发编程时更加强大和灵活。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11互斥体</title>
      <link href="/2024/05/06/c-11-hu-chi-ti/"/>
      <url>/2024/05/06/c-11-hu-chi-ti/</url>
      
        <content type="html"><![CDATA[<p>C++11引入了许多新特性来支持多线程编程，其中包括互斥体（mutex）和其他同步机制。互斥体提供了一种机制，用于<strong>确保多个线程在同一时刻不会访问共享资源 ，从而避免数据竞争。</strong>下面是对C++11互斥体的详细介绍。</p><h3 id="1-std-mutex"><a href="#1-std-mutex" class="headerlink" title="1. std::mutex"></a>1. <code>std::mutex</code></h3><p><code>std::mutex</code> 是 C++11 标准库中提供的用于多线程编程的基本互斥体类型。互斥体是一种同步原语，用于保护共享资源，确保同一时刻只有一个线程可以访问这些资源。</p><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><ul><li><code>std::mutex::mutex() noexcept</code>: 构造一个互斥体。</li><li><code>std::mutex::~mutex()</code>: 析构一个互斥体。如果互斥体当前处于锁定状态，析构函数的行为是未定义的。</li></ul><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li><code>void lock()</code><ul><li><strong>作用</strong>: 加锁互斥体。如果互斥体已经被其他线程锁定，则调用线程将阻塞，直到互斥体变为可用。</li><li><strong>异常</strong>: 如果在调用 <code>lock</code> 时互斥体已经被当前线程锁定，将导致未定义行为。</li></ul></li></ul><pre><code class="cpp">std::mutex mtx;mtx.lock();</code></pre><ul><li><code>bool try_lock() noexcept</code><ul><li><strong>作用</strong>: 尝试锁定互斥体。如果互斥体没有被其他线程锁定，则锁定并返回 <code>true</code>；如果互斥体已经被锁定，则立即返回 <code>false</code>。</li><li><strong>返回值</strong>: <code>true</code> 如果成功锁定互斥体；<code>false</code> 如果互斥体已经被锁定。</li></ul></li></ul><pre><code class="cpp">if (mtx.try_lock()) &#123;    // 成功锁定互斥体&#125; else &#123;    // 互斥体已经被其他线程锁定&#125;</code></pre><ul><li><code>void unlock()</code><ul><li><strong>作用</strong>: 解锁互斥体。如果当前线程没有持有该互斥体的锁，将导致未定义行为。</li><li><strong>异常</strong>: 这个函数是 <code>noexcept</code>，不会抛出异常。</li></ul></li></ul><pre><code class="cpp">mtx.unlock();</code></pre><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个完整的示例，演示如何使用 <code>std::mutex</code> 及其方法来保护共享资源。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;  // 定义一个互斥体void print_thread_id(int id) &#123;    mtx.lock();  // 加锁    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;    mtx.unlock();  // 解锁&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>在这个例子中，<code>mtx.lock()</code> 和 <code>mtx.unlock()</code> 确保了 <code>std::cout</code> 在同一时刻只能被一个线程访问，从而避免了输出竞争条件。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>死锁</strong>: 如果一个线程在没有解锁互斥体之前尝试再次锁定它，将导致死锁。因此，应该特别注意在每个加锁的地方确保有相应的解锁。</li><li><strong>异常安全性</strong>: 在加锁后的代码块中可能抛出异常，必须确保在异常抛出时能正确解锁互斥体。推荐使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 来自动管理锁的生命周期，避免手动管理锁的复杂性和潜在错误。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>构造函数和析构函数</strong>: 用于创建和销毁互斥体。</li><li><strong><code>lock()</code></strong>: 阻塞式加锁。</li><li><strong><code>try_lock()</code></strong>: 非阻塞式加锁。</li><li><strong><code>unlock()</code></strong>: 解锁。</li></ul><p>通过这些方法，可以在多线程编程中有效地保护共享资源，确保线程安全。</p><h3 id="2-std-lock-guard"><a href="#2-std-lock-guard" class="headerlink" title="2. std::lock_guard"></a>2. <code>std::lock_guard</code></h3><p><code>std::lock_guard</code> 是一种方便的 RAII 机制，用于<strong>自动管理互斥体的锁定和解锁</strong>。<strong>它在构造时锁定互斥体，在析构时解锁互斥体，确保互斥体在作用域结束时总是被解锁。</strong></p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;void print_thread_id(int id) &#123;    std::lock_guard&lt;std::mutex&gt; lock(mtx);    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>在这个例子中，<code>std::lock_guard</code> 确保了 <code>mtx</code> 在函数 <code>print_thread_id</code> 中的整个作用域内都是锁定的。</p><p>在 C++ 中，<code>std::lock_guard</code> 是一个用于自动管理互斥体锁定和解锁的工具，确保在作用域内互斥体被正确锁定和解锁。如果你写的是：</p><pre><code class="cpp">std::lock_guard lock(mtx);</code></pre><p>这在 C++17 及之后的标准中是正确的，因为从 C++17 开始，<code>std::lock_guard</code> 可以省略模板参数的类型推导。但是在 C++11 和 C++14 中，应该显式指定互斥体的类型。具体来说：</p><h3 id="C-11-和-C-14"><a href="#C-11-和-C-14" class="headerlink" title="C++11 和 C++14"></a>C++11 和 C++14</h3><p>在 C++11 和 C++14 中，你需要显式指定模板参数：</p><pre><code class="cpp">std::lock_guard&lt;std::mutex&gt; lock(mtx);</code></pre><h3 id="C-17-及之后的标准"><a href="#C-17-及之后的标准" class="headerlink" title="C++17 及之后的标准"></a>C++17 及之后的标准</h3><p>从 C++17 开始，你可以使用类型推导来简化代码：</p><pre><code class="cpp">std::lock_guard lock(mtx);  // C++17 及之后版本</code></pre><p>在这个版本中，编译器可以根据构造函数的参数 <code>mtx</code> 自动推导出 <code>std::lock_guard</code> 的模板参数类型为 <code>std::mutex</code>。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>这是一个使用 <code>std::lock_guard</code> 的完整示例：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;  // 定义一个全局互斥体void print_thread_id(int id) &#123;    std::lock_guard&lt;std::mutex&gt; lock(mtx);  // C++11 和 C++14 中必须指定模板参数    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>在 C++17 中，可以写成：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;  // 定义一个全局互斥体void print_thread_id(int id) &#123;    std::lock_guard lock(mtx);  // C++17 中可以省略模板参数    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>C++11 和 C++14</strong>: 使用 <code>std::lock_guard&lt;std::mutex&gt;</code> 明确指定模板参数类型。</li><li><strong>C++17 及之后</strong>: 可以使用 <code>std::lock_guard</code> 并省略模板参数，编译器会进行类型推导。</li></ul><h3 id="3-std-unique-lock"><a href="#3-std-unique-lock" class="headerlink" title="3. std::unique_lock"></a>3. <code>std::unique_lock</code></h3><p><code>std::unique_lock</code> 是一种更灵活的互斥体锁管理器。与 <code>std::lock_guard</code> 相比，<code>std::unique_lock</code> 还支持<strong>延迟锁定、锁定超时和锁的解锁&#x2F;重新锁定。</strong></p><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;void print_thread_id(int id) &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx);    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><h4 id="延迟锁定和手动锁定-解锁"><a href="#延迟锁定和手动锁定-解锁" class="headerlink" title="延迟锁定和手动锁定&#x2F;解锁"></a>延迟锁定和手动锁定&#x2F;解锁</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;void print_thread_id(int id) &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx, std::defer_lock); // 延迟锁定    // 其他操作    lock.lock(); // 手动锁定    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;    lock.unlock(); // 手动解锁    // 其他操作&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><h4 id="带超时的锁定"><a href="#带超时的锁定" class="headerlink" title="带超时的锁定"></a>带超时的锁定</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;std::mutex mtx;void try_lock_for_example() &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx, std::try_to_lock);    if (lock.owns_lock()) &#123;        std::cout &lt;&lt; &quot;Lock acquired.&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;Lock not acquired.&quot; &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    std::thread t1(try_lock_for_example);    std::thread t2(try_lock_for_example);    t1.join();    t2.join();    return 0;&#125;</code></pre><h3 id="4-std-timed-mutex-和-std-recursive-mutex"><a href="#4-std-timed-mutex-和-std-recursive-mutex" class="headerlink" title="4. std::timed_mutex 和 std::recursive_mutex"></a>4. <code>std::timed_mutex</code> 和 <code>std::recursive_mutex</code></h3><h3 id="std-timed-mutex"><a href="#std-timed-mutex" class="headerlink" title="std::timed_mutex"></a><code>std::timed_mutex</code></h3><p><code>std::timed_mutex</code> 是一种互斥体，除了提供基本的锁定和解锁功能外，还支持带超时的锁定操作。</p><h4 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li><code>void lock()</code><ul><li><strong>作用</strong>: 加锁互斥体。如果互斥体已经被其他线程锁定，则调用线程将阻塞，直到互斥体变为可用。</li><li><strong>异常</strong>: 如果在调用 <code>lock</code> 时互斥体已经被当前线程锁定，将导致未定义行为。</li></ul></li></ul><pre><code class="cpp">std::timed_mutex tmtx;tmtx.lock();</code></pre><ul><li><code>bool try_lock() noexcept</code><ul><li><strong>作用</strong>: 尝试锁定互斥体。如果互斥体没有被其他线程锁定，则锁定并返回 <code>true</code>；如果互斥体已经被锁定，则立即返回 <code>false</code>。</li><li><strong>返回值</strong>: <code>true</code> 如果成功锁定互斥体；<code>false</code> 如果互斥体已经被锁定。</li></ul></li></ul><pre><code class="cpp">if (tmtx.try_lock()) &#123;    // 成功锁定互斥体&#125; else &#123;    // 互斥体已经被其他线程锁定&#125;</code></pre><ul><li><code>bool try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code><ul><li><strong>作用</strong>: 尝试锁定互斥体，直到指定的相对时间间隔过去。如果互斥体在这段时间内变为可用，则锁定并返回 <code>true</code>；如果超时，则返回 <code>false</code>。</li><li><strong>参数</strong>: <code>rel_time</code> 指定的时间间隔。</li></ul></li></ul><pre><code class="cpp">if (tmtx.try_lock_for(std::chrono::seconds(1))) &#123;    // 成功锁定互斥体&#125; else &#123;    // 超时&#125;</code></pre><ul><li><code>bool try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</code><ul><li><strong>作用</strong>: 尝试锁定互斥体，直到指定的绝对时间点。如果互斥体在这段时间内变为可用，则锁定并返回 <code>true</code>；如果超时，则返回 <code>false</code>。</li><li><strong>参数</strong>: <code>abs_time</code> 指定的时间点。</li></ul></li></ul><pre><code class="cpp">if (tmtx.try_lock_until(std::chrono::steady_clock::now() + std::chrono::seconds(1))) &#123;    // 成功锁定互斥体&#125; else &#123;    // 超时&#125;</code></pre><ul><li><code>void unlock()</code><ul><li><strong>作用</strong>: 解锁互斥体。如果当前线程没有持有该互斥体的锁，将导致未定义行为。</li><li><strong>异常</strong>: 这个函数是 <code>noexcept</code>，不会抛出异常。</li></ul></li></ul><pre><code class="cpp">tmtx.unlock();</code></pre><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;std::timed_mutex tmtx;void try_lock_for_example() &#123;    if (tmtx.try_lock_for(std::chrono::seconds(1))) &#123;  // 尝试锁定，最多等待1秒        std::cout &lt;&lt; &quot;Lock acquired.&quot; &lt;&lt; std::endl;        tmtx.unlock();    &#125; else &#123;        std::cout &lt;&lt; &quot;Lock not acquired within timeout.&quot; &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    std::thread t1(try_lock_for_example);    std::thread t2(try_lock_for_example);    t1.join();    t2.join();    return 0;&#125;</code></pre><h3 id="std-recursive-mutex"><a href="#std-recursive-mutex" class="headerlink" title="std::recursive_mutex"></a><code>std::recursive_mutex</code></h3><p><code>std::recursive_mutex</code> 是一种递归互斥体，允许同一个线程多次锁定同一个互斥体，而不会导致死锁。每次调用 <code>lock</code> 必须有相应的 <code>unlock</code>。</p><h4 id="成员函数-2"><a href="#成员函数-2" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li><code>void lock()</code><ul><li><strong>作用</strong>: 加锁互斥体。如果互斥体已经被其他线程锁定，则调用线程将阻塞，直到互斥体变为可用。相同线程可以多次锁定互斥体。</li></ul></li></ul><pre><code class="cpp">std::recursive_mutex rmtx;rmtx.lock();rmtx.lock();  // 可以多次锁定</code></pre><ul><li><code>bool try_lock() noexcept</code><ul><li><strong>作用</strong>: 尝试锁定互斥体。如果互斥体没有被其他线程锁定或已经被当前线程锁定，则锁定并返回 <code>true</code>；如果互斥体已经被其他线程锁定，则立即返回 <code>false</code>。</li></ul></li></ul><pre><code class="cpp">if (rmtx.try_lock()) &#123;    // 成功锁定互斥体&#125; else &#123;    // 互斥体已经被其他线程锁定&#125;</code></pre><ul><li><code>void unlock()</code><ul><li><strong>作用</strong>: 解锁互斥体。如果当前线程多次锁定了互斥体，则每次调用 <code>unlock</code> 只减少一次锁定计数，直到计数归零后才真正解锁。</li></ul></li></ul><pre><code class="cpp">rmtx.unlock();rmtx.unlock();  // 必须匹配 lock 的次数</code></pre><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::recursive_mutex rmtx;void recursive_function(int count) &#123;    if (count &lt;= 0) return;    rmtx.lock();  // 可以多次锁定    std::cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; std::endl;    recursive_function(--count);    rmtx.unlock();  // 对应解锁&#125;int main() &#123;    std::thread t1(recursive_function, 3);    t1.join();    return 0;&#125;</code></pre><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong><code>std::timed_mutex</code></strong>:</p><ul><li>支持基本的锁定和解锁操作。</li><li>支持带超时的锁定操作，如 <code>try_lock_for</code> 和 <code>try_lock_until</code>。</li></ul></li><li><p><strong><code>std::recursive_mutex</code></strong>:</p><ul><li>允许同一线程多次锁定同一互斥体。</li><li>每次锁定必须有相应的解锁，确保正确管理锁计数。</li></ul></li></ul><p>这些工具在多线程编程中提供了灵活和安全的同步机制，帮助开发者有效地控制对共享资源的访问。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>C++11 提供了多种类型的互斥体和相应的锁管理工具来确保线程安全：</p><ul><li><code>std::mutex</code>：基本的互斥体类型。</li><li><code>std::lock_guard</code>：RAII 风格的互斥体管理。</li><li><code>std::unique_lock</code>：更灵活的锁管理，支持延迟锁定、超时锁定等。</li><li><code>std::timed_mutex</code>：支持带超时的锁定操作。</li><li><code>std::recursive_mutex</code>：允许同一线程多次锁定。</li></ul><p>这些工具帮助程序员更方便和安全地编写多线程程序，确保对共享资源的访问是互斥的，从而避免数据竞争和潜在的并发问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis数据库存取结构体数组数据</title>
      <link href="/2024/03/02/redis/"/>
      <url>/2024/03/02/redis/</url>
      
        <content type="html"><![CDATA[<p><code>hiredis</code> 是一个 C 语言编写的 Redis 客户端库，用于与 Redis 数据库交互。如果你想要通过 hiredis 存储和检索结构体数组的信息，你需要编写相应的 C 代码来处理这些操作。</p><p>下面我将给出一个简单的示例，展示如何使用 hiredis 在 Redis 中存储和检索结构体数组信息。我们将使用 Redis 的 <code>HMSET</code> 和 <code>HGETALL</code> 命令来处理结构体数组。</p><p>首先，让我们定义一个结构体来模拟你的需求：</p><pre><code class="c">typedef struct User &#123;    char *name;    int age;&#125; User;// 函数声明void storeUserInRedis(struct User *user, long id);void getUserFromRedis(long id, struct User *user);void printUser(const struct User *user);int main(void) &#123;    // 初始化 hiredis 和连接 Redis    redisContext *c = redisConnect(&quot;127.0.0.1&quot;, 6379);    if (c == NULL || c-&gt;err) &#123;        if (c) &#123;            printf(&quot;Error: %s\n&quot;, c-&gt;errstr);            redisFree(c);        &#125; else &#123;            printf(&quot;Connection error: can&#39;t allocate redis context\n&quot;);        &#125;        return 1;    &#125;    // 创建用户结构体    struct User fred = &#123;&quot;Fred&quot;, 25&#125;;    struct User alice = &#123;&quot;Alice&quot;, 30&#125;;    // 生成用户 ID    redisReply *reply = (redisReply *)redisCommand(c, &quot;INCR id:users&quot;);    long fred_id = reply-&gt;integer;    freeReplyObject(reply);    // 存储用户信息    storeUserInRedis(&amp;fred, fred_id);    // 再次生成用户 ID    reply = (redisReply *)redisCommand(c, &quot;INCR id:users&quot;);    long alice_id = reply-&gt;integer;    freeReplyObject(reply);    // 存储用户信息    storeUserInRedis(&amp;alice, alice_id);    // 从 Redis 中获取用户信息    struct User retrieved_user;    getUserFromRedis(fred_id, &amp;retrieved_user);    printUser(&amp;retrieved_user);    // 清理资源    redisFree(c);    free(retrieved_user.name); // 释放内存    return 0;&#125;void storeUserInRedis(struct User *user, long id) &#123;    redisReply *reply = (redisReply *)redisCommand(NULL, &quot;HMSET user:%ld name %s age %d&quot;, id, user-&gt;name, user-&gt;age);    freeReplyObject(reply);&#125;void getUserFromRedis(long id, struct User *user) &#123;    redisReply *reply = (redisReply *)redisCommand(NULL, &quot;HGETALL user:%ld&quot;, id);    if (reply-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; reply-&gt;elements &gt;= 4) &#123;        user-&gt;name = strdup(reply-&gt;element[1]-&gt;str);        user-&gt;age = atoi(reply-&gt;element[3]-&gt;str);    &#125;    freeReplyObject(reply);&#125;void printUser(const struct User *user) &#123;    printf(&quot;Name: %s, Age: %d\n&quot;, user-&gt;name, user-&gt;age);&#125;</code></pre><p>这个示例程序包含了以下几个部分：</p><ol><li><strong>定义结构体</strong>: <code>struct User</code> 包含用户的姓名和年龄。</li><li><strong>连接 Redis</strong>: 使用 <code>redisConnect</code> 连接到 Redis 服务器。</li><li><strong>生成用户 ID</strong>: 使用 <code>INCR</code> 命令递增 <code>id:users</code> 键的值。</li><li><strong>存储用户信息</strong>: 使用 <code>storeUserInRedis</code> 函数，该函数接受用户结构体和 ID 作为参数，并使用 <code>HMSET</code> 命令存储数据。</li><li><strong>获取用户信息</strong>: 使用 <code>getUserFromRedis</code> 函数，该函数接受用户 ID 和指向用户结构体的指针，使用 <code>HGETALL</code> 命令从 Redis 中获取数据并填充结构体。</li><li><strong>打印用户信息</strong>: 使用 <code>printUser</code> 函数来打印用户信息。</li></ol><p>请注意，在实际应用中你需要确保所有动态分配的内存都被正确释放，例如在 <code>getUserFromRedis</code> 函数中通过 <code>strdup</code> 分配的内存。在上面的示例中，我在 <code>main</code> 函数的最后释放了 <code>retrieved_user.name</code> 的内存。</p><p>这个示例假设你已经在 Redis 中设置了 <code>id:users</code> 键，如果没有的话，你需要先初始化它（例如通过 <code>DEL id:users</code> 和 <code>INCR id:users</code>）。此外，你需要安装 hiredis 库并且在编译时链接它。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决spawn-fcgi:child exited with:127报错</title>
      <link href="/2024/02/01/127-bao-cuo/"/>
      <url>/2024/02/01/127-bao-cuo/</url>
      
        <content type="html"><![CDATA[<p>解决spawn-fcgi:child exited with: 127报错</p><p>spawn-fcgi:child exited with: 127<br>原因：没有找到动态库</p><p>输入指令：ldd 你要运行的程序名<br>来查看缺少的库，如图我确少的是 libfcgi.so.0<br><img src="/images/1722491883237.png"></p><p>解决方案<br>先执行命令，查找所缺文件位置，比如我的（你实际操作时候一定要记住库名换成自己的，-name后面）</p><p><code>find usr/local/lib/ -name &quot;libfcgi.so&quot;</code></p><p><img src="/images/1722492061360.png"></p><p>得到库文件所在路径<code>/usr/local/lib</code></p><p>再执行<code>sudo vi /etc/ld.so.conf</code><br>在文件里添加你得到的库文件路径<code>/usr/local/lib</code>，之后保存退出</p><p><img src="/images/1722492201079.png"></p><p>最后执行<code>sudo ldconfig</code></p><p>再回到原来目录重新编译运行就成功了</p><p><img src="/images/1722492227287.png"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
