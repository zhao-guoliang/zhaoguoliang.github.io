<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>消息验证码和数字签名</title>
      <link href="/2024/07/29/xiao-xi-yan-zheng-ma-he-shu-zi-qian-ming/"/>
      <url>/2024/07/29/xiao-xi-yan-zheng-ma-he-shu-zi-qian-ming/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/07/29/she-ji-mo-shi/"/>
      <url>/2024/07/29/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<p><strong>工厂设计模式</strong></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std; // 引入 std 命名空间// 抽象产品类class Product &#123;public:    virtual void display() = 0;    virtual ~Product() &#123;&#125;&#125;;// 具体产品类 Aclass ConcreteProductA : public Product &#123;public:    void display() override &#123;        cout &lt;&lt; &quot;Concrete Product A&quot; &lt;&lt; endl;    &#125;&#125;;// 具体产品类 Bclass ConcreteProductB : public Product &#123;public:    void display() override &#123;        cout &lt;&lt; &quot;Concrete Product B&quot; &lt;&lt; endl;    &#125;&#125;;// 工厂类class Factory &#123;public:    // 静态方法，根据参数创建具体产品对象    static unique_ptr&lt;Product&gt; createProduct(char type) &#123;        switch (type) &#123;            case &#39;A&#39;:                return make_unique&lt;ConcreteProductA&gt;();            case &#39;B&#39;:                return make_unique&lt;ConcreteProductB&gt;();            default:                return nullptr;        &#125;    &#125;&#125;;int main() &#123;    // 使用工厂创建具体产品 A    unique_ptr&lt;Product&gt; productA = Factory::createProduct(&#39;A&#39;);    if (productA) &#123;        productA-&gt;display();    &#125;    // 使用工厂创建具体产品 B    unique_ptr&lt;Product&gt; productB = Factory::createProduct(&#39;B&#39;);    if (productB) &#123;        productB-&gt;display();    &#125;    // 使用工厂创建不存在的产品    unique_ptr&lt;Product&gt; productC = Factory::createProduct(&#39;C&#39;);    if (!productC) &#123;        cout &lt;&lt; &quot;Invalid product type requested.&quot; &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux配置环境变量</title>
      <link href="/2024/07/26/linux-pei-zhi-huan-jing-bian-liang/"/>
      <url>/2024/07/26/linux-pei-zhi-huan-jing-bian-liang/</url>
      
        <content type="html"><![CDATA[<p>当你在终端中输入 <code>echo $PATH</code> 并按回车，你会看到一系列由冒号分隔的目录路径。<code>$PATH</code> 是一个环境变量，它告诉你的系统在哪里查找可执行命令。每当你在终端输入一个命令，系统就会在 <code>$PATH</code> 变量列出的目录中搜索对应的可执行文件。</p><p><code>$PATH</code> 变量的值通常包括以下目录：</p><ul><li><code>/usr/local/bin</code>: 用户安装的本地应用程序的可执行文件。</li><li><code>/usr/bin</code>: 系统提供的标准应用程序。</li><li><code>/bin</code>: 基础的系统命令。</li><li><code>/usr/sbin</code>: 系统管理员使用的系统命令。</li><li><code>/sbin</code>: 基础的系统管理命令。</li><li><code>~/bin</code>: 用户个人的可执行文件目录。</li><li><code>/usr/local/sbin</code>: 类似于 <code>/usr/local/bin</code>，但用于系统管理命令。</li></ul><p>例如，<code>$PATH</code> 的输出可能类似于：</p><p><strong>&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:~&#x2F;bin</strong></p><p>这意味着当你在终端中输入 <code>ls</code>、<code>cd</code> 或任何其他命令时，系统会在这些目录中查找匹配的可执行文件。</p><p>你可以通过以下步骤将 &#x2F;usr&#x2F;local&#x2F;lib 添加到 PATH 环境变量中：<br>打开终端。<br>使用以下命令将 &#x2F;usr&#x2F;local&#x2F;lib 添加到当前会话的 PATH 环境变量：<br><code>export PATH=$PATH:/usr/local/lib</code><br>这只会在当前终端会话中生效。如果你关闭终端，设置将会丢失。</p><p>如果你希望永久性地将 &#x2F;usr&#x2F;local&#x2F;lib 添加到 PATH 环境变量中，你需要将上述命令添加到你的 shell 配置文件中。具体步骤如下：<br>对于 bash，编辑 ~&#x2F;.bashrc 文件：<br><code>echo &#39;export PATH=$PATH:/usr/local/lib&#39; &gt;&gt; ~/.bashrc</code></p><p>使配置文件生效：</p><p><code>source ~/.bashrc</code></p><p>这样，&#x2F;usr&#x2F;local&#x2F;lib 将被永久添加到 PATH 环境变量中，并在你每次打开新的终端会话时生效。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决spawn-fcgi:child exited with:127报错</title>
      <link href="/2024/02/01/127-bao-cuo/"/>
      <url>/2024/02/01/127-bao-cuo/</url>
      
        <content type="html"><![CDATA[<p>解决spawn-fcgi:child exited with: 127报错</p><p>spawn-fcgi:child exited with: 127<br>原因：没有找到动态库</p><p>输入指令：ldd 你要运行的程序名<br>来查看缺少的库，如图我确少的是 libfcgi.so.0<br><img src="/images/1722491883237.png"></p><p>解决方案<br>先执行命令，查找所缺文件位置，比如我的（你实际操作时候一定要记住库名换成自己的，-name后面）</p><p><code>find usr/local/lib/ -name &quot;libfcgi.so&quot;</code></p><p><img src="/images/1722492061360.png"></p><p>得到库文件所在路径<code>/usr/local/lib</code></p><p>再执行<code>sudo vi /etc/ld.so.conf</code><br>在文件里添加你得到的库文件路径<code>/usr/local/lib</code>，之后保存退出</p><p><img src="/images/1722492201079.png"></p><p>最后执行<code>sudo ldconfig</code></p><p>再回到原来目录重新编译运行就成功了</p><p><img src="/images/1722492227287.png"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
