<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c++11新特性</title>
      <link href="/2024/08/06/c-11-xin-te-xing/"/>
      <url>/2024/08/06/c-11-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<hr><p><code>int sum&#123;&#125;;</code> 是 C++11 引入的一个特性，用于初始化变量。这里的 <code>&#123;&#125;</code> 是一种 <strong>统一初始化</strong> 语法，它在 C++11 中引入并扩展了初始化的方式。</p><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ol><li><p><strong>值初始化</strong></p><p>当使用 <code>int sum&#123;&#125;;</code> 时，变量 <code>sum</code> 被值初始化。对于基本类型（如 <code>int</code>），值初始化将变量初始化为其默认值。在这种情况下，<code>int</code> 类型的变量将被初始化为 <code>0</code>。</p><pre><code class="cpp">int sum&#123;&#125;;  // sum 被初始化为 0</code></pre><p>这种初始化方式可以确保变量在声明时被初始化为确定的值，防止未初始化的变量导致潜在的错误。</p></li><li><p><strong>统一初始化语法</strong></p><p>C++11 引入了统一初始化语法 <code>&#123;&#125;</code>，使得初始化各种类型的变量变得一致。这种语法的主要好处包括：</p><ul><li><strong>防止窄化转换</strong>：使用 <code>&#123;&#125;</code> 语法时，如果初始化值的类型不能隐式转换为变量的类型，编译器会报错。例如，<code>int x&#123;3.14&#125;;</code> 会导致编译错误，因为 <code>3.14</code> 是 <code>double</code> 类型，而不能隐式转换为 <code>int</code>。</li><li><strong>统一的初始化方式</strong>：不论是内置类型还是自定义类型（如类和结构体），都可以使用 <code>&#123;&#125;</code> 进行初始化，提供了一致性。</li></ul><pre><code class="cpp">int x&#123;5&#125;;         // 初始化为 5double y&#123;3.14&#125;;   // 初始化为 3.14std::vector&lt;int&gt; v&#123;1, 2, 3&#125;; // 初始化 std::vector</code></pre></li><li><p><strong>值初始化 vs. 默认初始化</strong></p><ul><li><strong>值初始化</strong>：当变量在声明时使用 <code>&#123;&#125;</code> 进行初始化时，如 <code>int sum&#123;&#125;;</code>，它将被初始化为零或相应的默认值。</li><li><strong>默认初始化</strong>：当变量未显式初始化时，它的值是未定义的（对于基本类型）。例如，<code>int x;</code> 的值是未定义的，需要显式初始化以避免使用未定义值的风险。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>int sum&#123;&#125;;</code> 是 C++11 的统一初始化语法的一部分，它通过使用 <code>&#123;&#125;</code> 进行值初始化，将变量 <code>sum</code> 初始化为 <code>0</code>。这种语法简化了初始化的方式，并帮助防止潜在的错误。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11类型强制转换</title>
      <link href="/2024/08/05/c-11-lei-xing-qiang-zhi-zhuan-huan/"/>
      <url>/2024/08/05/c-11-lei-xing-qiang-zhi-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<p>在C++中，有四种主要的强制类型转换运算符：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code> 和 <code>reinterpret_cast</code>。每种类型转换运算符在编译时或运行时执行不同的检查。</p><h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. <code>static_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于进行隐式转换和显式转换。</li><li>适用于基本数据类型之间的转换、类层次结构中的上行转换（从派生类到基类）和下行转换（从基类到派生类，但无运行时检查）。</li><li>编译器在编译时进行类型检查，确保转换是有效的。</li></ul><pre><code class="cpp">int main() &#123;    int a = 10;    double b = static_cast&lt;double&gt;(a); // 编译时转换    return 0;&#125;</code></pre><h3 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. <code>dynamic_cast</code></h3><p><strong>检测时刻：运行时</strong></p><ul><li>主要用于多态类型转换（基类指针&#x2F;引用到派生类指针&#x2F;引用）。</li><li>需要基类有至少一个虚函数，以启用运行时类型信息（RTTI）。</li><li>在运行时进行类型检查，如果转换失败，指针类型返回 <code>nullptr</code>，引用类型抛出 <code>std::bad_cast</code> 异常。</li></ul><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base &#123;public:    virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;int main() &#123;    Base* basePtr = new Derived();    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);    if (derivedPtr) &#123;        derivedPtr-&gt;derivedFunction(); // 运行时转换    &#125; else &#123;        std::cout &lt;&lt; &quot;Conversion failed&quot; &lt;&lt; std::endl;    &#125;    delete basePtr;    return 0;&#125;</code></pre><h3 id="3-const-cast"><a href="#3-const-cast" class="headerlink" title="3. const_cast"></a>3. <code>const_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于修改类型的 <code>const</code> 或 <code>volatile</code> 属性。</li><li>主要用于将 <code>const</code> 指针或引用转换为非 <code>const</code>，反之亦然。</li><li>编译器在编译时进行类型检查。</li></ul><pre><code class="cpp">int main() &#123;    const int a = 10;    int* p = const_cast&lt;int*&gt;(&amp;a); // 编译时转换    *p = 20; // 可能导致未定义行为    // 10    /*    原因：因为编译器可能会将 const 变量的值内联到代码中，因此即使修改了内存中的值，输出结果仍可能显示原始的 const 值。    */    cout&lt;&lt;a&lt;&lt;endl;    return 0;&#125;</code></pre><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. <code>reinterpret_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于进行低级别的、无类型安全检查的转换。</li><li>适用于指针类型之间的转换、将指针转换为整数类型或反之。</li><li>编译器在编译时进行类型检查，但不保证转换的安全性。</li></ul><pre><code class="cpp">int main() &#123;    int a = 10;    void* p = reinterpret_cast&lt;void*&gt;(&amp;a); // 编译时转换    int* q = reinterpret_cast&lt;int*&gt;(p);    return 0;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>static_cast</code>：编译时检测，适用于安全的类型转换，如基本数据类型和类层次结构。</li><li><code>dynamic_cast</code>：运行时检测，适用于多态类型转换，需要运行时类型检查。</li><li><code>const_cast</code>：编译时检测，适用于修改 <code>const</code> 或 <code>volatile</code> 属性。</li><li><code>reinterpret_cast</code>：编译时检测，适用于低级别、不安全的类型转换。</li></ul><p>了解这些类型转换运算符的用途和检测时刻，有助于在编写 C++ 程序时进行适当的类型转换，确保代码的安全性和正确性。</p><h3 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1.const_cast"></a>1.const_cast</h3><p><code>const_cast</code> 是 C++ 中的一个类型转换运算符，用于去除或添加指针或引用的常量性。与其他类型转换运算符不同，<code>const_cast</code> 只能用于修改类型的 <code>const</code> 或 <code>volatile</code> 属性。</p><h3 id="const-cast-基本语法"><a href="#const-cast-基本语法" class="headerlink" title="const_cast 基本语法"></a><code>const_cast</code> 基本语法</h3><pre><code class="cpp">const_cast&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型。</li><li><code>expression</code>：要转换的表达式。</li></ul><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><ol><li><strong>去除常量性</strong>：将 <code>const</code> 指针或引用转换为非 <code>const</code>，允许修改对象。</li><li><strong>添加常量性</strong>：将非 <code>const</code> 指针或引用转换为 <code>const</code>。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="去除常量性"><a href="#去除常量性" class="headerlink" title="去除常量性"></a>去除常量性</h4><pre><code class="cpp">int main() &#123;    const int n = 42;    // 将 const int* 转换为 int*    int* p = const_cast&lt;int*&gt;(&amp;n);        // 修改值，尽管这种修改可能导致未定义行为    *p = 24;        std::cout &lt;&lt; &quot;n: &quot; &lt;&lt; n &lt;&lt; std::endl;      return 0;&#125;</code></pre><h4 id="成员函数中去除常量性"><a href="#成员函数中去除常量性" class="headerlink" title="成员函数中去除常量性"></a>成员函数中去除常量性</h4><p>在某些情况下，成员函数被声明为 <code>const</code>，但是你需要修改成员变量。可以使用 <code>const_cast</code> 去除 <code>const</code> 属性。</p><pre><code class="cpp">class MyClass &#123;public:    MyClass(int val) : value(val) &#123;&#125;    void setValue(int val) const &#123;        // 去除 this 指针的常量性        const_cast&lt;MyClass*&gt;(this)-&gt;value = val;    &#125;    int getValue() const &#123;        return value;    &#125;private:    int value;&#125;;int main() &#123;    const MyClass obj(10);    obj.setValue(20);  // 修改常量对象的成员变量    std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; obj.getValue() &lt;&lt; std::endl;  // 输出 20    return 0;&#125;</code></pre><h4 id="与库函数的兼容性"><a href="#与库函数的兼容性" class="headerlink" title="与库函数的兼容性"></a>与库函数的兼容性</h4><p>有时你需要调用一个不接受 <code>const</code> 参数的旧库函数。你可以使用 <code>const_cast</code> 去除 <code>const</code> 属性来与这样的函数兼容。</p><pre><code class="cpp">void legacyFunction(char* str) &#123;    std::cout &lt;&lt; &quot;Legacy function: &quot; &lt;&lt; str &lt;&lt; std::endl;&#125;int main() &#123;    const char* text = &quot;Hello, world!&quot;;    // 将 const char* 转换为 char*    legacyFunction(const_cast&lt;char*&gt;(text));    return 0;&#125;</code></pre><h3 id="添加常量性"><a href="#添加常量性" class="headerlink" title="添加常量性"></a>添加常量性</h3><p>虽然不常见，但也可以使用 <code>const_cast</code> 添加常量性。</p><pre><code class="cpp">int main() &#123;    int n = 42;    // 将 int* 转换为 const int*    const int* p = const_cast&lt;const int*&gt;(&amp;n);    // 现在 p 是一个 const int*，不能通过它修改 n    // *p = 24;  // 错误，不能修改    return 0;&#125;</code></pre><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><p><strong>未定义行为</strong>：通过 <code>const_cast</code> 去除常量性并修改对象，如果对象本身是常量的（例如，定义为 <code>const</code>），这种修改会导致未定义行为。</p><pre><code class="cpp">const int n = 42;int* p = const_cast&lt;int*&gt;(&amp;n);*p = 24;  </code></pre></li><li><p><strong>设计意图</strong>：<code>const_cast</code> 应该仅用于你确定不会破坏代码逻辑和设计意图的情况下。常量性通常用于保护数据不被意外修改，因此应谨慎使用 <code>const_cast</code>。</p></li><li><p><strong>兼容性</strong>：<code>const_cast</code> 的主要用途是为了与旧的、不使用 <code>const</code> 修饰的代码或库进行兼容。在新的代码中，尽量避免使用 <code>const_cast</code>，并采用更为安全的设计。</p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>const_cast</code> 是一个功能强大的类型转换工具，用于在 C++ 中处理 <code>const</code> 和 <code>volatile</code> 属性。尽管它在某些场景下非常有用，但由于可能引发未定义行为，因此应谨慎使用，并尽量在设计时避免需要使用它的情况。</p><h3 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2.static_cast"></a>2.static_cast</h3><p><code>static_cast</code> 是 C++ 中的一种类型转换运算符，用于在编译时执行类型转换。与 <code>reinterpret_cast</code> 和 <code>const_cast</code> 不同，<code>static_cast</code> 更加安全，因为它只能在特定类型之间进行转换，并且在编译时进行检查。它适用于以下几种常见的类型转换场景：</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="cpp">static_cast&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型。</li><li><code>expression</code>：要转换的表达式。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p><strong>基本数据类型之间的转换</strong>：</p><pre><code class="cpp">int main() &#123;    float f = 3.14;    int i = static_cast&lt;int&gt;(f);  // 将 float 转换为 int    std::cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; std::endl;  // 输出 i: 3    return 0;&#125;</code></pre></li><li><p><strong>指针类型之间的转换</strong>：</p><pre><code class="cpp">class Base &#123;&#125;;class Derived : public Base &#123;&#125;;int main() &#123;    Derived d;    Base* b = static_cast&lt;Base*&gt;(&amp;d);  // 将 Derived* 转换为 Base*    return 0;&#125;</code></pre></li><li><p><strong>将空指针转换为其他指针类型</strong>：</p><pre><code class="cpp">int main() &#123;    void* ptr = nullptr;    int* intPtr = static_cast&lt;int*&gt;(ptr);  // 将 void* 转换为 int*    return 0;&#125;</code></pre></li><li><p><strong>转换枚举类型</strong>：</p><pre><code class="cpp">enum Color &#123; RED, GREEN, BLUE &#125;;int main() &#123;    Color c = RED;    int colorInt = static_cast&lt;int&gt;(c);  // 将枚举类型转换为 int    std::cout &lt;&lt; &quot;colorInt: &quot; &lt;&lt; colorInt &lt;&lt; std::endl;  // 输出 colorInt: 0    return 0;&#125;</code></pre></li><li><p><strong>基础类和派生类之间的转换</strong>：</p><pre><code class="cpp">class Base &#123;public:    virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;&#125;&#125;;int main() &#123;    Base* b = new Derived();    Derived* d = static_cast&lt;Derived*&gt;(b);  // 将 Base* 转换为 Derived*    d-&gt;derivedFunction();  // 调用派生类的方法    delete b;    return 0;&#125;</code></pre></li><li><p><strong>有意义的类型转换运算符</strong>：</p><pre><code class="cpp">class Complex &#123;public:    Complex(double real, double imag) : real(real), imag(imag) &#123;&#125;    // 定义转换运算符，将 Complex 转换为 double    operator double() const &#123;        return real;    &#125;private:    double real;    double imag;&#125;;int main() &#123;    Complex c(3.0, 4.0);    double realPart = static_cast&lt;double&gt;(c);  // 使用转换运算符将 Complex 转换为 double    std::cout &lt;&lt; &quot;realPart: &quot; &lt;&lt; realPart &lt;&lt; std::endl;  // 输出 realPart: 3.0    return 0;&#125;</code></pre></li></ol><h3 id="使用注意事项-1"><a href="#使用注意事项-1" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><p><strong>安全性</strong>：<code>static_cast</code> 进行的是编译时检查，因此相对于 <code>reinterpret_cast</code> 更为安全。但它不能用于去除 <code>const</code>、<code>volatile</code> 限定符，也不能进行不相关类型的转换。</p></li><li><p><strong>适用场景</strong>：适用于基本数据类型、指针类型、枚举类型、类层次结构中的上行转换和下行转换（必须确保安全下行）。</p></li><li><p><strong>避免未定义行为</strong>：在进行基类和派生类之间的转换时，必须确保转换是安全的，即被转换对象实际是派生类类型，否则会导致未定义行为。</p></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>static_cast</code> 是 C++ 中一种安全且常用的类型转换运算符，适用于多种类型转换场景。它在编译时进行类型检查，相比 <code>reinterpret_cast</code> 和 <code>const_cast</code> 更加安全可靠。在使用时，确保理解转换的类型和语义，以避免潜在的未定义行为。</p><p><code>dynamic_cast</code> 是 C++ 中的一种类型转换运算符，用于在运行时进行安全的类型转换。它主要用于处理继承层次结构中的指针或引用，特别是在多态（polymorphism）情况下。<code>dynamic_cast</code> 通过运行时类型检查（RTTI, Run-Time Type Information）来确保转换的安全性。如果转换失败，指针类型会返回 <code>nullptr</code>，引用类型会抛出 <code>std::bad_cast</code> 异常。</p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="cpp">dynamic_cast&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型，必须是一个指针或引用类型。</li><li><code>expression</code>：要转换的表达式，通常是一个指向基类的指针或引用。</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>向下转换（Downcasting）</strong>：将基类指针或引用转换为派生类指针或引用。</li><li><strong>横向转换（Sidecasting）</strong>：在有多重继承的情况下，从一个基类指针转换为另一个基类指针。</li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="向下转换"><a href="#向下转换" class="headerlink" title="向下转换"></a>向下转换</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base &#123;public:    virtual ~Base() &#123;&#125;  // 必须有虚函数以启用 RTTI&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;int main() &#123;    Base* basePtr = new Derived();  // 基类指针指向派生类对象    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);    if (derivedPtr) &#123;        derivedPtr-&gt;derivedFunction();  // 安全调用派生类函数    &#125; else &#123;        std::cout &lt;&lt; &quot;Conversion failed&quot; &lt;&lt; std::endl;    &#125;    delete basePtr;    return 0;&#125;</code></pre><h4 id="横向转换"><a href="#横向转换" class="headerlink" title="横向转换"></a>横向转换</h4><pre><code class="cpp">#include &lt;iostream&gt;class Base1 &#123;public:    virtual ~Base1() &#123;&#125;&#125;;class Base2 &#123;public:    virtual ~Base2() &#123;&#125;&#125;;class Derived : public Base1, public Base2 &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;int main() &#123;    Base1* base1Ptr = new Derived();  // Base1 指针指向 Derived 对象    Base2* base2Ptr = dynamic_cast&lt;Base2*&gt;(base1Ptr);    if (base2Ptr) &#123;        std::cout &lt;&lt; &quot;Successfully cast Base1* to Base2*&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;Conversion failed&quot; &lt;&lt; std::endl;    &#125;    delete base1Ptr;    return 0;&#125;</code></pre><h4 id="引用类型的转换"><a href="#引用类型的转换" class="headerlink" title="引用类型的转换"></a>引用类型的转换</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base &#123;public:    virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;void process(Base&amp; baseRef) &#123;    try &#123;        Derived&amp; derivedRef = dynamic_cast&lt;Derived&amp;&gt;(baseRef);        derivedRef.derivedFunction();    &#125; catch (const std::bad_cast&amp; e) &#123;        std::cerr &lt;&lt; &quot;Bad cast: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    Derived derivedObj;    Base&amp; baseRef = derivedObj;    process(baseRef);  // 安全转换并调用派生类方法    return 0;&#125;</code></pre><h3 id="使用注意事项-2"><a href="#使用注意事项-2" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol><li><strong>必须有虚函数</strong>：基类必须有至少一个虚函数，以便启用运行时类型信息（RTTI）。</li><li><strong>转换失败处理</strong>：在使用指针类型时，转换失败会返回 <code>nullptr</code>，在使用引用类型时，转换失败会抛出 <code>std::bad_cast</code> 异常。</li><li><strong>性能考虑</strong>：<code>dynamic_cast</code> 在运行时进行类型检查，因此相对于 <code>static_cast</code> 有一定的性能开销。</li><li><strong>避免不必要的转换</strong>：尽量设计代码避免频繁使用 <code>dynamic_cast</code>，如果可能，使用更优雅的设计模式，如策略模式或访问者模式。</li></ol><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><code>dynamic_cast</code> 是一个强大的工具，用于在 C++ 中处理继承层次结构中的类型安全转换。它通过运行时类型检查来确保转换的安全性，适用于向下转换和横向转换。理解和正确使用 <code>dynamic_cast</code> 可以帮助你编写更加健壮和安全的面向对象代码。</p><h3 id="4-reinterpret-cast-1"><a href="#4-reinterpret-cast-1" class="headerlink" title="4.reinterpret_cast"></a>4.reinterpret_cast</h3><p><code>reinterpret_cast</code> 是 C++ 中的一种类型转换运算符，用于强制转换指针、引用和其他类型之间。与其他类型转换运算符（如 <code>static_cast</code>、<code>dynamic_cast</code> 和 <code>const_cast</code>）不同，<code>reinterpret_cast</code> 可以执行非常规的类型转换，包括不安全的和未定义行为的转换，因此使用时需要特别小心。</p><h3 id="使用场景和示例"><a href="#使用场景和示例" class="headerlink" title="使用场景和示例"></a>使用场景和示例</h3><ol><li><p><strong>指针类型之间的转换</strong>：</p><pre><code class="cpp">int main() &#123;    int n = 42;    // 将 int* 转换为 char*    char* p = reinterpret_cast&lt;char*&gt;(&amp;n);    // 输出指针 p 所指向的值    std::cout &lt;&lt; *p &lt;&lt; std::endl;  // 注意：输出的值依赖于系统的字节序和类型大小    return 0;&#125;</code></pre></li><li><p><strong>将整数转换为指针类型</strong>：</p><pre><code class="cpp">int main() &#123;    intptr_t addr = 0x12345678;  // 整数地址    // 将整数转换为指针    int* p = reinterpret_cast&lt;int*&gt;(addr);    // 打印指针地址    std::cout &lt;&lt; p &lt;&lt; std::endl;    return 0;&#125;</code></pre></li><li><p><strong>将指针转换为整数类型</strong>：</p><pre><code class="cpp">int main() &#123;    int n = 42;    int* p = &amp;n;    // 将指针转换为整数    intptr_t addr = reinterpret_cast&lt;intptr_t&gt;(p);    // 打印整数地址    std::cout &lt;&lt; std::hex &lt;&lt; addr &lt;&lt; std::endl;    return 0;&#125;</code></pre></li><li><p><strong>指向对象的指针转换为指向不同类型对象的指针</strong>：</p><pre><code class="cpp">struct A &#123;    int x;&#125;;struct B &#123;    int y;&#125;;int main() &#123;    A a;    a.x = 10;    // 将 A* 转换为 B*    B* b = reinterpret_cast&lt;B*&gt;(&amp;a);    // 注意：访问 b-&gt;y 是不安全的，因为它不是 B 对象    std::cout &lt;&lt; b-&gt;y &lt;&lt; std::endl;  // 未定义行为    return 0;&#125;</code></pre></li></ol><h3 id="使用注意事项-3"><a href="#使用注意事项-3" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><strong>不安全</strong>：<code>reinterpret_cast</code> 可以执行不安全的转换，这可能导致未定义行为。</li><li><strong>可移植性</strong>：<code>reinterpret_cast</code> 的行为可能依赖于具体的编译器和平台，因此使用时要考虑代码的可移植性。</li><li><strong>用途有限</strong>：应该尽量减少使用 <code>reinterpret_cast</code>，除非确实需要进行底层的、特定的类型转换，且确定不会导致未定义行为。</li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>reinterpret_cast</code> 是一种功能强大但危险的类型转换运算符，主要用于需要底层操作的场景。使用时应确保转换是合理且安全的，以避免潜在的未定义行为和难以调试的问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++的const</title>
      <link href="/2024/08/05/c-de-const/"/>
      <url>/2024/08/05/c-de-const/</url>
      
        <content type="html"><![CDATA[<h1 id="C-const-关键字小结"><a href="#C-const-关键字小结" class="headerlink" title="C++ const 关键字小结"></a>C++ <code>const</code> 关键字小结</h1><p><code>const</code> 是 constant 的缩写，本意是不变的、不易改变的意思。在 C++ 中，</p><p><code>const</code> 用来修饰内置类型变量、自定义对象、成员函数、返回值、函数参数。</p><h2 id="1-C语言的-const-特点"><a href="#1-C语言的-const-特点" class="headerlink" title="1. C语言的 const 特点"></a>1. C语言的 <code>const</code> 特点</h2><p>const int a &#x3D; 10; &#x2F;&#x2F; 不要把a看成常量<br>&#x2F;&#x2F; a的本质是变量，只是只读变量</p><p>C语言的 <code>const</code> 修饰全局变量默认是（外部链接的）。</p><h3 id="fun-c"><a href="#fun-c" class="headerlink" title="fun.c"></a>fun.c</h3><pre><code class="cpp">// C语言的const修饰全局变量默认是（外部链接的）// 外部链接: 其他源文件可以使用const int num = 100; // 只读的全局变量，内存放在文字常量区（内存空间只读）</code></pre><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><pre><code class="cpp">// 对fun.c中的num进行声明(不要赋值)extern const int num;void test03() &#123;    printf(&quot;num = %d\n&quot;, num);    // num = 200; // err num只读    // C语言中const修饰变量名，说明变量名为只读（用户不能通过变量名data进行赋值）    const int data = 100; // 局部只读变量，内存在栈区（内存可读可写）    // data = 200; // err    printf(&quot;data = %d\n&quot;, data);    // 但是：如果知道data的地址，可以通过地址间接地修改data所对应空间的内容    int *p = (int *)&amp;data;    *p = 2000;    printf(&quot;data = %d\n&quot;, data); // ok 2000&#125;</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li><code>const</code> 修饰全局变量 <code>num</code>，变量名只读，内存空间在文字常量区（只读），不能通过 <code>num</code> 的地址修改空间内容。</li><li><code>const</code> 修饰局部变量 <code>data</code>，变量名只读，内存空间在栈区（可读可写），可以通过 <code>data</code> 地址间接地修改空间内容。</li></ol><h2 id="2-C-中的-const-深入理解"><a href="#2-C-中的-const-深入理解" class="headerlink" title="2. C++中的 const 深入理解"></a>2. C++中的 <code>const</code> 深入理解</h2><p><img src="/images/v2-cfd0b188ea87aeb4eed52737f45697b9_r.jpg"></p><h3 id="fun-cpp"><a href="#fun-cpp" class="headerlink" title="fun.cpp"></a>fun.cpp</h3><pre><code class="cpp">// const修饰的全局变量默认是内部链接（只在当前源文件有效，不能直接用于其他源文件）// const int num = 100;// 如果必须用在其他源文件使用只读的全局变量，必须加 extern 将 num 转换成外部链接extern const int num = 100;</code></pre><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><pre><code class="cpp">// 声明extern const int num;struct Person &#123;    int num;    char name[32];&#125;;void test04() &#123;    cout &lt;&lt; &quot;全局num = &quot; &lt;&lt; num &lt;&lt; endl; // err 不识别num    // 1. C++中，对于基础类型，系统不会给data开辟空间，data放到符号表中    const int data = 10;    // data = 100; // err 只读    cout &lt;&lt; &quot;data = &quot; &lt;&lt; data &lt;&lt; endl;    // 2. C++中当对data取地址的时候，系统就会给data开辟空间    int *p = (int *)&amp;data;    *p = 2000;    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; // 空间内容修改成功 2000    cout &lt;&lt; &quot;data = &quot; &lt;&lt; data &lt;&lt; endl; // data 还是10，为啥？    // 2. 当以变量的形式初始化const修饰的变量，系统会为其开辟空间    int b = 200;    const int a = b; // 系统直接为a开辟空间，而不会把a放入符号表中    p = (int *)&amp;a;    *p = 3000;    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; // 3000    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // 3000    // 3. const修饰自定义数据类型（结构体、对象），系统会分配空间    const Person per = &#123;100, &quot;lucy&quot;&#125;;    // per.num = 1000; // err    cout &lt;&lt; &quot;num = &quot; &lt;&lt; per.num &lt;&lt; &quot;, name = &quot; &lt;&lt; per.name &lt;&lt; endl; // 100 lucy    Person *p1 = (Person *)&amp;per;    p1-&gt;num = 2000;    cout &lt;&lt; &quot;num = &quot; &lt;&lt; per.num &lt;&lt; &quot;, name = &quot; &lt;&lt; per.name &lt;&lt; endl; // 2000 lucy&#125;</code></pre><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="/%5Cimages%5CSnipaste_2024-08-05_22-41-30.png"></p><p>C++的<code>const</code>总结：</p><ol><li><code>const int data = 10;</code> &#x2F;&#x2F; data先放入符号表</li><li>如果对data取地址，系统才会给data开辟空间</li><li><code>const int a = b;</code> &#x2F;&#x2F; b是变量名，系统直接给a开辟空间，而不放入符号表</li><li><code>const</code> 修饰自定义数据，系统为自定义数据开辟空间</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cmp报错</title>
      <link href="/2024/08/05/cmp-bao-cuo/"/>
      <url>/2024/08/05/cmp-bao-cuo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11智能指针</title>
      <link href="/2024/08/05/c-11-zhi-neng-zhi-zhen/"/>
      <url>/2024/08/05/c-11-zhi-neng-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h3 id="共享智能指针"><a href="#共享智能指针" class="headerlink" title="共享智能指针"></a>共享智能指针</h3><h3 id="1-shared-ptr的初始化"><a href="#1-shared-ptr的初始化" class="headerlink" title="1.shared_ptr的初始化"></a>1.shared_ptr的初始化</h3><p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针<code>shared_ptr</code> 是一个模板类，如果要进行初始化有三种方式：通过<strong>构造函数</strong>、<strong>make_shared辅助函数</strong>以及<strong>reset方法</strong>。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数<code>use_count</code>，函数原型如下：</p><pre><code class="c++">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。long use_count() const noexcept;</code></pre><h5 id="1-1-构造函数初始化"><a href="#1-1-构造函数初始化" class="headerlink" title="1.1 构造函数初始化"></a>1.1 构造函数初始化</h5><p>shared_ptr<T> 类模板中，提供了多种实用的构造函数, 语法格式如下:<br>shared_ptr<T> 智能指针名字(创建堆内存);</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存    shared_ptr&lt;int&gt; ptr1(new int(520));    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;        // 使用智能指针管理一块字符数组对应的堆内存    shared_ptr&lt;char&gt; ptr2(new char[12]);    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;        // 创建智能指针对象, 不管理任何内存    shared_ptr&lt;int&gt; ptr3;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;        // 创建智能指针对象, 初始化为空    shared_ptr&lt;int&gt; ptr4(nullptr);    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    return 0;&#125;</code></pre><p>测试代码输出的结果如下:</p><p>ptr1管理的内存引用计数: 1<br>ptr2管理的内存引用计数: 1<br>ptr3管理的内存引用计数: 0<br>ptr4管理的内存引用计数: 0</p><p>如果智能指针被初始化了一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为<code>nullptr</code>空指针，引用计数不会+1。另外，不要使用一个原始指针初始化多个<code>shared_ptr</code>。</p><pre><code class="c++">int *p = new int;shared_ptr&lt;int&gt; p1(p);    //原始指针只能吃初始化一个智能指针shared_ptr&lt;int&gt; p2(p);// error, 编译不会报错, 运行会出错</code></pre><h5 id="1-2-通过拷贝和移动构造函数初始化"><a href="#1-2-通过拷贝和移动构造函数初始化" class="headerlink" title="1.2 通过拷贝和移动构造函数初始化"></a>1.2 通过拷贝和移动构造函数初始化</h5><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1    shared_ptr&lt;int&gt; ptr1(new int(520));    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;        //调用拷贝构造函数    shared_ptr&lt;int&gt; ptr2(ptr1);    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    shared_ptr&lt;int&gt; ptr3 = ptr1;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;        //调用移动构造函数    shared_ptr&lt;int&gt; ptr4(move(ptr1));    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    std::shared_ptr&lt;int&gt; ptr5 = move(ptr2);    cout &lt;&lt; &quot;ptr5管理的内存引用计数: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;        return 0;&#125;</code></pre><p>测试程序输入的结果：<br>ptr1管理的内存引用计数: 1<br>ptr2管理的内存引用计数: 2<br>ptr3管理的内存引用计数: 3<br>ptr4管理的内存引用计数: 3<br>ptr5管理的内存引用计数: 3</p><p>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。</p><h5 id="1-3-通过make-shared初始化"><a href="#1-3-通过make-shared初始化" class="headerlink" title="1.3 通过make_shared初始化"></a>1.3 通过make_shared初始化</h5><p>通过C++提供的make_shared() 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p><pre><code class="c++">template&lt; class T, class... Args &gt;shared_ptr&lt;T&gt; make_shared( Args&amp;&amp;... args );//T：模板参数的数据类型//Args&amp;&amp;... args ：要初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定</code></pre><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;class Test&#123;public:    Test()     &#123;        cout &lt;&lt; &quot;construct Test...&quot; &lt;&lt; endl;    &#125;    Test(int x)     &#123;        cout &lt;&lt; &quot;construct Test, x = &quot; &lt;&lt; x &lt;&lt; endl;    &#125;    Test(string str)     &#123;        cout &lt;&lt; &quot;construct Test, str = &quot; &lt;&lt; str &lt;&lt; endl;    &#125;    ~Test()    &#123;        cout &lt;&lt; &quot;destruct Test ...&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1    shared_ptr&lt;int&gt; ptr1 = make_shared&lt;int&gt;(520);    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;    shared_ptr&lt;Test&gt; ptr2 = make_shared&lt;Test&gt;();    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    shared_ptr&lt;Test&gt; ptr3 = make_shared&lt;Test&gt;(520);    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;    shared_ptr&lt;Test&gt; ptr4 = make_shared&lt;Test&gt;(&quot;我是要成为海贼王的男人!!!&quot;);    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    return 0;&#125;</code></pre><p>使用std::make_shared()模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。</p><h5 id="1-4-通过-reset方法初始化"><a href="#1-4-通过-reset方法初始化" class="headerlink" title="1.4 通过 reset方法初始化"></a>1.4 通过 reset方法初始化</h5><p>共享智能指针类提供的std::shared_ptr::reset方法函数原型如下：</p><pre><code class="c++">void reset() noexcept;template&lt; class Y &gt;void reset( Y* ptr );template&lt; class Y, class Deleter &gt;void reset( Y* ptr, Deleter d );template&lt; class Y, class Deleter, class Alloc &gt;void reset( Y* ptr, Deleter d, Alloc alloc );</code></pre><p>ptr：指向要取得所有权的对象的指针<br>d：指向要取得所有权的对象的指针<br>aloc：内部存储所用的分配器</p><p>测试代码如下：</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1    shared_ptr&lt;int&gt; ptr1 = make_shared&lt;int&gt;(520);    shared_ptr&lt;int&gt; ptr2 = ptr1;    shared_ptr&lt;int&gt; ptr3 = ptr1;    shared_ptr&lt;int&gt; ptr4 = ptr1;    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    ptr4.reset();    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;        shared_ptr&lt;int&gt; ptr5;    ptr5.reset(new int(250));    cout &lt;&lt; &quot;ptr5管理的内存引用计数: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;        return 0;&#125;</code></pre><p>测试代码输入的结果:</p><p>ptr1管理的内存引用计数: 4<br>ptr2管理的内存引用计数: 4<br>ptr3管理的内存引用计数: 4<br>ptr4管理的内存引用计数: 4</p><p>ptr1管理的内存引用计数: 3<br>ptr2管理的内存引用计数: 3<br>ptr3管理的内存引用计数: 3<br>ptr4管理的内存引用计数: 0</p><p>ptr5管理的内存引用计数: 1</p><p><strong>对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。</strong></p><h5 id="1-5-获取原始指针"><a href="#1-5-获取原始指针" class="headerlink" title="1.5 获取原始指针"></a>1.5 获取原始指针</h5><p>通过智能指针可以管理一个普通变量或者对象的地址，此时原始地址就不可见了。当我们想要修改变量或者对象中的值的时候，就需要从智能指针对象中先取出数据的原始内存的地址再操作，解决方案是调用共享智能指针类提供的get()方法，其函数原型如下：</p><p><code>T* get() const noexcept;</code></p><p>测试代码如下:</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    int len = 128;    shared_ptr&lt;char&gt; ptr(new char[len]);        // 得到指针的原始地址    char* add = ptr.get();    memset(add, 0, len);    strcpy(add, &quot;我是要成为海贼王的男人!!!&quot;);    cout &lt;&lt; &quot;string: &quot; &lt;&lt; add &lt;&lt; endl;        shared_ptr&lt;int&gt; p(new int);    *p = 100;    cout &lt;&lt; *p.get() &lt;&lt; &quot;  &quot; &lt;&lt; *p &lt;&lt; endl;        return 0;&#125;</code></pre><h3 id="指定删除器"><a href="#指定删除器" class="headerlink" title="指定删除器"></a>指定删除器</h3><p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;// 自定义删除器函数，释放int型内存void deleteIntPtr(int* p)&#123;    delete p;    cout &lt;&lt; &quot;int 型内存被释放了...&quot;;&#125;int main()&#123;    shared_ptr&lt;int&gt; ptr(new int(250), deleteIntPtr);    return 0;&#125;//删除器函数也可以是lambda表达式，因此代码也可以写成下面这样：int main()&#123;    shared_ptr&lt;int&gt; ptr(new int(250), [](int* p) &#123;delete p; &#125;);    return 0;&#125;</code></pre><p>在上面的代码中，lambda表达式的参数就是智能指针管理的内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。</p><p>在C++11中使用<code>shared_ptr</code>管理动态数组时，需要指定删除器，因为<code>shared_ptr</code>的<em>默认删除器不支持数组对象</em>，具体的处理代码如下：</p><pre><code class="c++">int main()&#123;    shared_ptr&lt;int&gt; ptr(new int[10], [](int* p) &#123;delete[]p; &#125;);    return 0;&#125;/*在删除数组内存时，除了自己编写删除器，也可以使用C++提供的default_delete&lt;T&gt;()函数作为删除器，这个函数内部的删除功能也是通过调用delete来实现的，要释放什么类型的内存就将模板类型T指定为什么类型即可。具体处理代码如下：*/int main()&#123;    shared_ptr&lt;int&gt; ptr(new int[10], default_delete&lt;int[]&gt;());    return 0;&#125;</code></pre><p>另外，我们还可以自己封装一个<code>make_shared_array</code>方法来让<code>shared_ptr</code>支持数组，代码如下:</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;template &lt;typename T&gt;shared_ptr&lt;T&gt; make_share_array(size_t size)&#123;    // 返回匿名对象    return shared_ptr&lt;T&gt;(new T[size], default_delete&lt;T[]&gt;());&#125;int main()&#123;    shared_ptr&lt;int&gt; ptr1 = make_share_array&lt;int&gt;(10);    cout &lt;&lt; ptr1.use_count() &lt;&lt; endl;    shared_ptr&lt;char&gt; ptr2 = make_share_array&lt;char&gt;(128);    cout &lt;&lt; ptr2.use_count() &lt;&lt; endl;    return 0;&#125;</code></pre><p><code>shared_ptr</code>使用注意事项:</p><p>1.不能使用一个原始地址初始化多个共享智能指针。</p><p>2.函数不能返回管理了this的共享智能指针对象。</p><p>3.共享智能指针不能循环引用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消息验证码和数字签名</title>
      <link href="/2024/07/29/xiao-xi-yan-zheng-ma-he-shu-zi-qian-ming/"/>
      <url>/2024/07/29/xiao-xi-yan-zheng-ma-he-shu-zi-qian-ming/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/07/29/she-ji-mo-shi/"/>
      <url>/2024/07/29/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<p><strong>工厂设计模式</strong></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std; // 引入 std 命名空间// 抽象产品类class Product &#123;public:    virtual void display() = 0;    virtual ~Product() &#123;&#125;&#125;;// 具体产品类 Aclass ConcreteProductA : public Product &#123;public:    void display() override &#123;        cout &lt;&lt; &quot;Concrete Product A&quot; &lt;&lt; endl;    &#125;&#125;;// 具体产品类 Bclass ConcreteProductB : public Product &#123;public:    void display() override &#123;        cout &lt;&lt; &quot;Concrete Product B&quot; &lt;&lt; endl;    &#125;&#125;;// 工厂类class Factory &#123;public:    // 静态方法，根据参数创建具体产品对象    static unique_ptr&lt;Product&gt; createProduct(char type) &#123;        switch (type) &#123;            case &#39;A&#39;:                return make_unique&lt;ConcreteProductA&gt;();            case &#39;B&#39;:                return make_unique&lt;ConcreteProductB&gt;();            default:                return nullptr;        &#125;    &#125;&#125;;int main() &#123;    // 使用工厂创建具体产品 A    unique_ptr&lt;Product&gt; productA = Factory::createProduct(&#39;A&#39;);    if (productA) &#123;        productA-&gt;display();    &#125;    // 使用工厂创建具体产品 B    unique_ptr&lt;Product&gt; productB = Factory::createProduct(&#39;B&#39;);    if (productB) &#123;        productB-&gt;display();    &#125;    // 使用工厂创建不存在的产品    unique_ptr&lt;Product&gt; productC = Factory::createProduct(&#39;C&#39;);    if (!productC) &#123;        cout &lt;&lt; &quot;Invalid product type requested.&quot; &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux配置环境变量</title>
      <link href="/2024/07/26/linux-pei-zhi-huan-jing-bian-liang/"/>
      <url>/2024/07/26/linux-pei-zhi-huan-jing-bian-liang/</url>
      
        <content type="html"><![CDATA[<p>当你在终端中输入 <code>echo $PATH</code> 并按回车，你会看到一系列由冒号分隔的目录路径。<code>$PATH</code> 是一个环境变量，它告诉你的系统在哪里查找可执行命令。每当你在终端输入一个命令，系统就会在 <code>$PATH</code> 变量列出的目录中搜索对应的可执行文件。</p><p><code>$PATH</code> 变量的值通常包括以下目录：</p><ul><li><code>/usr/local/bin</code>: 用户安装的本地应用程序的可执行文件。</li><li><code>/usr/bin</code>: 系统提供的标准应用程序。</li><li><code>/bin</code>: 基础的系统命令。</li><li><code>/usr/sbin</code>: 系统管理员使用的系统命令。</li><li><code>/sbin</code>: 基础的系统管理命令。</li><li><code>~/bin</code>: 用户个人的可执行文件目录。</li><li><code>/usr/local/sbin</code>: 类似于 <code>/usr/local/bin</code>，但用于系统管理命令。</li></ul><p>例如，<code>$PATH</code> 的输出可能类似于：</p><p><strong>&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:~&#x2F;bin</strong></p><p>这意味着当你在终端中输入 <code>ls</code>、<code>cd</code> 或任何其他命令时，系统会在这些目录中查找匹配的可执行文件。</p><p>你可以通过以下步骤将 &#x2F;usr&#x2F;local&#x2F;lib 添加到 PATH 环境变量中：<br>打开终端。<br>使用以下命令将 &#x2F;usr&#x2F;local&#x2F;lib 添加到当前会话的 PATH 环境变量：<br><code>export PATH=$PATH:/usr/local/lib</code><br>这只会在当前终端会话中生效。如果你关闭终端，设置将会丢失。</p><p>如果你希望永久性地将 &#x2F;usr&#x2F;local&#x2F;lib 添加到 PATH 环境变量中，你需要将上述命令添加到你的 shell 配置文件中。具体步骤如下：<br>对于 bash，编辑 ~&#x2F;.bashrc 文件：<br><code>echo &#39;export PATH=$PATH:/usr/local/lib&#39; &gt;&gt; ~/.bashrc</code></p><p>使配置文件生效：</p><p><code>source ~/.bashrc</code></p><p>这样，&#x2F;usr&#x2F;local&#x2F;lib 将被永久添加到 PATH 环境变量中，并在你每次打开新的终端会话时生效。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11线程库</title>
      <link href="/2024/05/06/c-11-xian-cheng-ku/"/>
      <url>/2024/05/06/c-11-xian-cheng-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="1-std-thread"><a href="#1-std-thread" class="headerlink" title="1. std::thread"></a>1. <code>std::thread</code></h2><p><code>std::thread</code> 类用于创建和管理线程。每个 <code>std::thread</code> 对象表示一个线程，能够执行任何可调用的对象。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ul><li><p><strong>构造函数</strong>：创建线程并执行指定的函数或可调用对象。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;void print_message(const std::string&amp; message) &#123;    std::cout &lt;&lt; message &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t(print_message, &quot;Hello from thread!&quot;); // 创建线程并传递参数    t.join(); // 等待线程完成    return 0;&#125;</code></pre></li><li><p>**<code>join()</code> 和 <code>detach()</code>**：</p><ul><li>**<code>join()</code>**：等待线程执行完成。主线程会阻塞，直到 <code>join()</code> 的线程完成。</li><li>**<code>detach()</code>**：将线程分离，让它在后台继续运行，不会阻塞主线程。如果线程对象超出作用域，分离线程的资源会被自动释放，但主线程不会等待它完成。</li></ul><pre><code class="cpp">std::thread t(print_message, &quot;Hello from detached thread!&quot;);t.detach(); // 让线程在后台运行</code></pre></li></ul><h2 id="2-std-this-thread"><a href="#2-std-this-thread" class="headerlink" title="2. std::this_thread"></a>2. <code>std::this_thread</code></h2><p><code>std::this_thread</code> 提供了与当前线程相关的功能。</p><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><ul><li><p>**<code>std::this_thread::sleep_for()</code>**：让当前线程休眠指定的时间段。</p><pre><code class="cpp">#include &lt;thread&gt;#include &lt;chrono&gt;int main() &#123;    std::this_thread::sleep_for(std::chrono::seconds(2)); // 休眠 2 秒    return 0;&#125;</code></pre></li><li><p>**<code>std::this_thread::sleep_until()</code>**：让当前线程休眠直到指定的时间点。</p><pre><code class="cpp">#include &lt;thread&gt;#include &lt;chrono&gt;int main() &#123;    auto wake_up_time = std::chrono::steady_clock::now() + std::chrono::seconds(2);    std::this_thread::sleep_until(wake_up_time); // 休眠直到指定时间点    return 0;&#125;</code></pre></li><li><p>**<code>std::this_thread::get_id()</code>**：获取当前线程的 ID。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;int main() &#123;    std::cout &lt;&lt; &quot;Current thread ID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;    return 0;&#125;</code></pre></li></ul><ul><li><p><code>std::this_thread::yield()</code> 是 C++11 引入的一种函数，用于在多线程程序中使当前线程自愿让出 CPU 时间，以便其他线程可以执行。这是一个简洁而有效的方法，用于实现线程的协作和调度，尤其是在涉及线程优先级和负载均衡时。</p><h4 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h4><pre><code class="cpp">#include &lt;thread&gt;void yield();</code></pre><ul><li>**<code>std::this_thread::yield()</code>**：使当前线程让出 CPU 时间，将其从运行状态转变为就绪状态，让调度器有机会安排其他线程运行。</li></ul><h4 id="2-工作机制"><a href="#2-工作机制" class="headerlink" title="2. 工作机制"></a>2. 工作机制</h4><ul><li><p><strong>让出 CPU</strong>：调用 <code>std::this_thread::yield()</code> 让当前线程放弃它的剩余时间片，从而允许其他线程（包括优先级较高的线程或同等优先级的线程）获得 CPU 时间。线程在调用 <code>yield</code> 后会回到就绪队列等待重新调度。</p></li><li><p><strong>调度行为</strong>：<code>yield</code> 的具体行为依赖于操作系统和线程调度策略。在某些操作系统中，<code>yield</code> 可能不会立即让当前线程放弃 CPU 时间，而是在当前时间片结束时调度其他线程。在其他系统中，<code>yield</code> 可能会更快地将当前线程移到就绪队列中。</p></li></ul><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h4><ul><li><p><strong>避免忙等待</strong>：在某些多线程应用中，线程可能需要等待某些条件的改变。在这种情况下，使用 <code>std::this_thread::yield()</code> 可以避免忙等待（即不断循环检查条件），从而降低 CPU 使用率并允许其他线程运行。</p></li><li><p><strong>线程协作</strong>：当线程间需要协调工作时，<code>yield</code> 可以让线程主动让出控制权，从而允许其他线程执行某些操作，尤其是在没有严格的优先级要求时。</p></li><li><p><strong>测试和调试</strong>：在调试多线程应用时，<code>yield</code> 可以帮助模拟不同的线程调度情况，观察系统的行为和性能。</p></li></ul><h4 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h4><p>下面的示例展示了如何使用 <code>std::this_thread::yield</code> 来实现简单的线程协作：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;atomic&gt;std::atomic&lt;bool&gt; flag&#123;false&#125;;void thread1() &#123;    while (!flag.load()) &#123;        std::this_thread::yield(); // 让出 CPU 时间    &#125;    std::cout &lt;&lt; &quot;Thread 1 finished&quot; &lt;&lt; std::endl;&#125;void thread2() &#123;    std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟工作    flag.store(true);    std::cout &lt;&lt; &quot;Thread 2 finished&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(thread1);    std::thread t2(thread2);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>在这个示例中：</p><ul><li><code>thread1</code> 线程会在 <code>flag</code> 为 <code>false</code> 时不断调用 <code>std::this_thread::yield()</code>，让出 CPU 时间。</li><li><code>thread2</code> 线程在睡眠一秒后设置 <code>flag</code> 为 <code>true</code>，使 <code>thread1</code> 能够继续执行。</li></ul><h4 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h4><ul><li><p><strong>性能影响</strong>：<code>yield</code> 的使用可能会影响性能，特别是在高负载或高频率调用时。需要在合适的场景下使用，以避免不必要的性能开销。</p></li><li><p><strong>操作系统依赖</strong>：<code>yield</code> 的行为依赖于底层操作系统的线程调度实现，因此不同操作系统可能会有不同的行为表现。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>std::this_thread::yield</code> 是一个用于线程协作和调度的有用工具，使当前线程主动让出 CPU 时间，从而允许其他线程执行。它在多线程程序中能够有效地避免忙等待、实现线程协作，并帮助调试和测试。正确使用 <code>yield</code> 可以提高线程间的协调性，但也需要注意它对性能的潜在影响。</p></li></ul><h2 id="3-std-future-和-std-promise"><a href="#3-std-future-和-std-promise" class="headerlink" title="3. std::future 和 std::promise"></a>3. <code>std::future</code> 和 <code>std::promise</code></h2><p><code>std::future</code> 和 <code>std::promise</code> 用于异步操作的结果传递和同步。</p><h3 id="std-promise-和-std-future"><a href="#std-promise-和-std-future" class="headerlink" title="std::promise 和 std::future"></a><code>std::promise</code> 和 <code>std::future</code></h3><ul><li><p>**<code>std::promise</code>**：用于设置一个值或异常，供其他线程通过 <code>std::future</code> 获取。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;void produce(std::promise&lt;int&gt;&amp;&amp; prom) &#123;    std::this_thread::sleep_for(std::chrono::seconds(1));    prom.set_value(42); // 设置结果值&#125;int main() &#123;    std::promise&lt;int&gt; prom;    std::future&lt;int&gt; fut = prom.get_future(); // 获取 future 对象    std::thread t(produce, std::move(prom)); // 将 promise 移动到线程    std::cout &lt;&lt; &quot;Waiting for result...&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl; // 获取结果    t.join();    return 0;&#125;</code></pre></li></ul><p>这段代码演示了如何使用 <code>std::promise</code> 和 <code>std::future</code> 在多线程程序中传递结果。以下是对这段代码的详细解释：</p><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol><li><p><strong>创建 <code>std::promise</code> 对象</strong></p><pre><code class="cpp">std::promise&lt;int&gt; prom;</code></pre><p><code>std::promise&lt;int&gt;</code> 用于在线程之间传递结果。它允许一个线程设置一个值，另一个线程获取这个值。</p></li><li><p><strong>获取 <code>std::future</code> 对象</strong></p><pre><code class="cpp">std::future&lt;int&gt; fut = prom.get_future();</code></pre><p>从 <code>std::promise</code> 对象中获取 <code>std::future</code> 对象。<code>std::future</code> 用于异步获取 <code>std::promise</code> 设置的值。</p></li><li><p><strong>将 <code>std::promise</code> 移动到线程中</strong></p><pre><code class="cpp">std::thread t(produce, std::move(prom));</code></pre><p><code>std::promise</code> 对象通过 <code>std::move</code> 被移动到新线程中执行。移动是必须的，因为 <code>std::promise</code> 对象在线程间传递时不支持拷贝。</p></li><li><p><strong>在新线程中设置值</strong></p><pre><code class="cpp">void produce(std::promise&lt;int&gt;&amp;&amp; prom) &#123;    std::this_thread::sleep_for(std::chrono::seconds(1));    prom.set_value(42);&#125;</code></pre><p><code>produce</code> 函数模拟一个耗时操作（通过 <code>std::this_thread::sleep_for</code>），然后使用 <code>prom.set_value(42)</code> 设置 <code>std::promise</code> 的值。这个值将被传递到 <code>std::future</code> 中。</p></li><li><p><strong>获取结果并输出</strong></p><pre><code class="cpp">std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl;</code></pre><p><code>fut.get()</code> 阻塞当前线程，直到 <code>std::promise</code> 设置的值可用。<code>fut.get()</code> 返回这个值，并输出到控制台。</p></li><li><p><strong>等待线程完成</strong></p><pre><code class="cpp">t.join();</code></pre><p><code>t.join()</code> 等待 <code>produce</code> 线程完成执行，确保程序在退出前 <code>produce</code> 线程已经执行完毕。</p></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这段代码演示了如何使用 <code>std::promise</code> 和 <code>std::future</code> 来实现线程间的结果传递：</p><ul><li><code>std::promise</code> 用于设置一个值。</li><li><code>std::future</code> 用于获取这个值。</li><li>通过 <code>std::move</code> 将 <code>std::promise</code> 移动到线程中进行设置。</li><li>使用 <code>fut.get()</code> 获取结果并输出。</li></ul><p>这种方式在处理异步操作和线程间的结果传递时非常有用。</p><ul><li><p>**<code>std::future</code>**：用于获取异步操作的结果。可以通过 <code>get()</code> 方法获取结果，或者使用 <code>wait()</code> 和 <code>wait_for()</code> 等方法等待结果的到来。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;int compute_value() &#123;    std::this_thread::sleep_for(std::chrono::seconds(1));    return 42;&#125;int main() &#123;    std::future&lt;int&gt; fut = std::async(std::launch::async, compute_value); // 异步计算    std::cout &lt;&lt; &quot;Waiting for result...&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl; // 获取结果    return 0;&#125;</code></pre></li></ul><h2 id="4-std-async"><a href="#4-std-async" class="headerlink" title="4. std::async"></a>4. <code>std::async</code></h2><p><code>std::async</code> 用于启动一个异步任务并返回 <code>std::future</code> 对象，可以用于获取异步操作的结果。</p><h3 id="使用-std-async"><a href="#使用-std-async" class="headerlink" title="使用 std::async"></a>使用 <code>std::async</code></h3><ul><li><p>**<code>std::launch::async</code>**：强制异步执行。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;int compute_value() &#123;    std::this_thread::sleep_for(std::chrono::seconds(1));    return 42;&#125;int main() &#123;    std::future&lt;int&gt; fut = std::async(std::launch::async, compute_value); // 异步计算    std::cout &lt;&lt; &quot;Waiting for result...&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl; // 获取结果    return 0;&#125;</code></pre></li><li><p>**<code>std::launch::deferred</code>**：推迟执行，直到 <code>get()</code> 或 <code>wait()</code> 被调用。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;int compute_value() &#123;    std::cout &lt;&lt; &quot;Computing...&quot; &lt;&lt; std::endl;    return 42;&#125;int main() &#123;    std::future&lt;int&gt; fut = std::async(std::launch::deferred, compute_value); // 推迟执行    std::cout &lt;&lt; &quot;Waiting for result...&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl; // 执行并获取结果    return 0;&#125;</code></pre></li></ul><h2 id="5-std-atomic"><a href="#5-std-atomic" class="headerlink" title="5. std::atomic"></a>5. <code>std::atomic</code></h2><p><code>std::atomic</code> 提供原子操作，用于处理共享数据时避免数据竞争。适用于基本数据类型，如 <code>int</code>、<code>bool</code> 等。</p><h3 id="使用-std-atomic"><a href="#使用-std-atomic" class="headerlink" title="使用 std::atomic"></a>使用 <code>std::atomic</code></h3><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;std::atomic&lt;int&gt; counter(0);void increment() &#123;    for (int i = 0; i &lt; 1000; ++i) &#123;        ++counter; // 原子操作，避免数据竞争    &#125;&#125;int main() &#123;    std::thread t1(increment);    std::thread t2(increment);    t1.join();    t2.join();    std::cout &lt;&lt; &quot;Counter: &quot; &lt;&lt; counter &lt;&lt; std::endl;    return 0;&#125;</code></pre><h3 id="原子操作的常用方法"><a href="#原子操作的常用方法" class="headerlink" title="原子操作的常用方法"></a>原子操作的常用方法</h3><ul><li>**<code>store()</code>**：设置值。</li><li>**<code>load()</code>**：获取值。</li><li>**<code>fetch_add()</code><strong>、</strong><code>fetch_sub()</code>**：原子性加法和减法。</li><li>**<code>compare_exchange_weak()</code><strong>、</strong><code>compare_exchange_strong()</code>**：原子比较和交换操作。</li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>C++11 的线程库引入了多个功能强大的组件来支持多线程编程：</p><ul><li>**<code>std::thread</code>**：创建和管理线程。</li><li>**<code>std::this_thread</code>**：提供与当前线程相关的功能，如休眠和获取线程 ID。</li><li>**<code>std::future</code> 和 <code>std::promise</code>**：用于异步操作的结果传递和同步。</li><li>**<code>std::async</code>**：启动异步任务并返回 <code>std::future</code> 对象。</li><li>**<code>std::atomic</code>**：提供原子操作，处理多线程中的基本数据类型。</li></ul><p>这些工具和类使得 C++11 在处理并发编程时更加强大和灵活。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11互斥体</title>
      <link href="/2024/05/06/c-11-hu-chi-ti/"/>
      <url>/2024/05/06/c-11-hu-chi-ti/</url>
      
        <content type="html"><![CDATA[<p>C++11引入了许多新特性来支持多线程编程，其中包括互斥体（mutex）和其他同步机制。互斥体提供了一种机制，用于<strong>确保多个线程在同一时刻不会访问共享资源 ，从而避免数据竞争。</strong>下面是对C++11互斥体的详细介绍。</p><h3 id="1-std-mutex"><a href="#1-std-mutex" class="headerlink" title="1. std::mutex"></a>1. <code>std::mutex</code></h3><p><code>std::mutex</code> 是 C++11 标准库中提供的用于多线程编程的基本互斥体类型。互斥体是一种同步原语，用于保护共享资源，确保同一时刻只有一个线程可以访问这些资源。</p><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><ul><li><code>std::mutex::mutex() noexcept</code>: 构造一个互斥体。</li><li><code>std::mutex::~mutex()</code>: 析构一个互斥体。如果互斥体当前处于锁定状态，析构函数的行为是未定义的。</li></ul><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li><code>void lock()</code><ul><li><strong>作用</strong>: 加锁互斥体。如果互斥体已经被其他线程锁定，则调用线程将阻塞，直到互斥体变为可用。</li><li><strong>异常</strong>: 如果在调用 <code>lock</code> 时互斥体已经被当前线程锁定，将导致未定义行为。</li></ul></li></ul><pre><code class="cpp">std::mutex mtx;mtx.lock();</code></pre><ul><li><code>bool try_lock() noexcept</code><ul><li><strong>作用</strong>: 尝试锁定互斥体。如果互斥体没有被其他线程锁定，则锁定并返回 <code>true</code>；如果互斥体已经被锁定，则立即返回 <code>false</code>。</li><li><strong>返回值</strong>: <code>true</code> 如果成功锁定互斥体；<code>false</code> 如果互斥体已经被锁定。</li></ul></li></ul><pre><code class="cpp">if (mtx.try_lock()) &#123;    // 成功锁定互斥体&#125; else &#123;    // 互斥体已经被其他线程锁定&#125;</code></pre><ul><li><code>void unlock()</code><ul><li><strong>作用</strong>: 解锁互斥体。如果当前线程没有持有该互斥体的锁，将导致未定义行为。</li><li><strong>异常</strong>: 这个函数是 <code>noexcept</code>，不会抛出异常。</li></ul></li></ul><pre><code class="cpp">mtx.unlock();</code></pre><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个完整的示例，演示如何使用 <code>std::mutex</code> 及其方法来保护共享资源。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;  // 定义一个互斥体void print_thread_id(int id) &#123;    mtx.lock();  // 加锁    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;    mtx.unlock();  // 解锁&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>在这个例子中，<code>mtx.lock()</code> 和 <code>mtx.unlock()</code> 确保了 <code>std::cout</code> 在同一时刻只能被一个线程访问，从而避免了输出竞争条件。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>死锁</strong>: 如果一个线程在没有解锁互斥体之前尝试再次锁定它，将导致死锁。因此，应该特别注意在每个加锁的地方确保有相应的解锁。</li><li><strong>异常安全性</strong>: 在加锁后的代码块中可能抛出异常，必须确保在异常抛出时能正确解锁互斥体。推荐使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 来自动管理锁的生命周期，避免手动管理锁的复杂性和潜在错误。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>构造函数和析构函数</strong>: 用于创建和销毁互斥体。</li><li><strong><code>lock()</code></strong>: 阻塞式加锁。</li><li><strong><code>try_lock()</code></strong>: 非阻塞式加锁。</li><li><strong><code>unlock()</code></strong>: 解锁。</li></ul><p>通过这些方法，可以在多线程编程中有效地保护共享资源，确保线程安全。</p><h3 id="2-std-lock-guard"><a href="#2-std-lock-guard" class="headerlink" title="2. std::lock_guard"></a>2. <code>std::lock_guard</code></h3><p><code>std::lock_guard</code> 是一种方便的 RAII 机制，用于<strong>自动管理互斥体的锁定和解锁</strong>。<strong>它在构造时锁定互斥体，在析构时解锁互斥体，确保互斥体在作用域结束时总是被解锁。</strong></p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;void print_thread_id(int id) &#123;    std::lock_guard&lt;std::mutex&gt; lock(mtx);    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>在这个例子中，<code>std::lock_guard</code> 确保了 <code>mtx</code> 在函数 <code>print_thread_id</code> 中的整个作用域内都是锁定的。</p><p>在 C++ 中，<code>std::lock_guard</code> 是一个用于自动管理互斥体锁定和解锁的工具，确保在作用域内互斥体被正确锁定和解锁。如果你写的是：</p><pre><code class="cpp">std::lock_guard lock(mtx);</code></pre><p>这在 C++17 及之后的标准中是正确的，因为从 C++17 开始，<code>std::lock_guard</code> 可以省略模板参数的类型推导。但是在 C++11 和 C++14 中，应该显式指定互斥体的类型。具体来说：</p><h3 id="C-11-和-C-14"><a href="#C-11-和-C-14" class="headerlink" title="C++11 和 C++14"></a>C++11 和 C++14</h3><p>在 C++11 和 C++14 中，你需要显式指定模板参数：</p><pre><code class="cpp">std::lock_guard&lt;std::mutex&gt; lock(mtx);</code></pre><h3 id="C-17-及之后的标准"><a href="#C-17-及之后的标准" class="headerlink" title="C++17 及之后的标准"></a>C++17 及之后的标准</h3><p>从 C++17 开始，你可以使用类型推导来简化代码：</p><pre><code class="cpp">std::lock_guard lock(mtx);  // C++17 及之后版本</code></pre><p>在这个版本中，编译器可以根据构造函数的参数 <code>mtx</code> 自动推导出 <code>std::lock_guard</code> 的模板参数类型为 <code>std::mutex</code>。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>这是一个使用 <code>std::lock_guard</code> 的完整示例：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;  // 定义一个全局互斥体void print_thread_id(int id) &#123;    std::lock_guard&lt;std::mutex&gt; lock(mtx);  // C++11 和 C++14 中必须指定模板参数    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>在 C++17 中，可以写成：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;  // 定义一个全局互斥体void print_thread_id(int id) &#123;    std::lock_guard lock(mtx);  // C++17 中可以省略模板参数    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>C++11 和 C++14</strong>: 使用 <code>std::lock_guard&lt;std::mutex&gt;</code> 明确指定模板参数类型。</li><li><strong>C++17 及之后</strong>: 可以使用 <code>std::lock_guard</code> 并省略模板参数，编译器会进行类型推导。</li></ul><h3 id="3-std-unique-lock"><a href="#3-std-unique-lock" class="headerlink" title="3. std::unique_lock"></a>3. <code>std::unique_lock</code></h3><p><code>std::unique_lock</code> 是一种更灵活的互斥体锁管理器。与 <code>std::lock_guard</code> 相比，<code>std::unique_lock</code> 还支持<strong>延迟锁定、锁定超时和锁的解锁&#x2F;重新锁定。</strong></p><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;void print_thread_id(int id) &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx);    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><h4 id="延迟锁定和手动锁定-解锁"><a href="#延迟锁定和手动锁定-解锁" class="headerlink" title="延迟锁定和手动锁定&#x2F;解锁"></a>延迟锁定和手动锁定&#x2F;解锁</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;void print_thread_id(int id) &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx, std::defer_lock); // 延迟锁定    // 其他操作    lock.lock(); // 手动锁定    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;    lock.unlock(); // 手动解锁    // 其他操作&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><h4 id="带超时的锁定"><a href="#带超时的锁定" class="headerlink" title="带超时的锁定"></a>带超时的锁定</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;std::mutex mtx;void try_lock_for_example() &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx, std::try_to_lock);    if (lock.owns_lock()) &#123;        std::cout &lt;&lt; &quot;Lock acquired.&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;Lock not acquired.&quot; &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    std::thread t1(try_lock_for_example);    std::thread t2(try_lock_for_example);    t1.join();    t2.join();    return 0;&#125;</code></pre><h3 id="4-std-timed-mutex-和-std-recursive-mutex"><a href="#4-std-timed-mutex-和-std-recursive-mutex" class="headerlink" title="4. std::timed_mutex 和 std::recursive_mutex"></a>4. <code>std::timed_mutex</code> 和 <code>std::recursive_mutex</code></h3><h3 id="std-timed-mutex"><a href="#std-timed-mutex" class="headerlink" title="std::timed_mutex"></a><code>std::timed_mutex</code></h3><p><code>std::timed_mutex</code> 是一种互斥体，除了提供基本的锁定和解锁功能外，还支持带超时的锁定操作。</p><h4 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li><code>void lock()</code><ul><li><strong>作用</strong>: 加锁互斥体。如果互斥体已经被其他线程锁定，则调用线程将阻塞，直到互斥体变为可用。</li><li><strong>异常</strong>: 如果在调用 <code>lock</code> 时互斥体已经被当前线程锁定，将导致未定义行为。</li></ul></li></ul><pre><code class="cpp">std::timed_mutex tmtx;tmtx.lock();</code></pre><ul><li><code>bool try_lock() noexcept</code><ul><li><strong>作用</strong>: 尝试锁定互斥体。如果互斥体没有被其他线程锁定，则锁定并返回 <code>true</code>；如果互斥体已经被锁定，则立即返回 <code>false</code>。</li><li><strong>返回值</strong>: <code>true</code> 如果成功锁定互斥体；<code>false</code> 如果互斥体已经被锁定。</li></ul></li></ul><pre><code class="cpp">if (tmtx.try_lock()) &#123;    // 成功锁定互斥体&#125; else &#123;    // 互斥体已经被其他线程锁定&#125;</code></pre><ul><li><code>bool try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code><ul><li><strong>作用</strong>: 尝试锁定互斥体，直到指定的相对时间间隔过去。如果互斥体在这段时间内变为可用，则锁定并返回 <code>true</code>；如果超时，则返回 <code>false</code>。</li><li><strong>参数</strong>: <code>rel_time</code> 指定的时间间隔。</li></ul></li></ul><pre><code class="cpp">if (tmtx.try_lock_for(std::chrono::seconds(1))) &#123;    // 成功锁定互斥体&#125; else &#123;    // 超时&#125;</code></pre><ul><li><code>bool try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</code><ul><li><strong>作用</strong>: 尝试锁定互斥体，直到指定的绝对时间点。如果互斥体在这段时间内变为可用，则锁定并返回 <code>true</code>；如果超时，则返回 <code>false</code>。</li><li><strong>参数</strong>: <code>abs_time</code> 指定的时间点。</li></ul></li></ul><pre><code class="cpp">if (tmtx.try_lock_until(std::chrono::steady_clock::now() + std::chrono::seconds(1))) &#123;    // 成功锁定互斥体&#125; else &#123;    // 超时&#125;</code></pre><ul><li><code>void unlock()</code><ul><li><strong>作用</strong>: 解锁互斥体。如果当前线程没有持有该互斥体的锁，将导致未定义行为。</li><li><strong>异常</strong>: 这个函数是 <code>noexcept</code>，不会抛出异常。</li></ul></li></ul><pre><code class="cpp">tmtx.unlock();</code></pre><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;std::timed_mutex tmtx;void try_lock_for_example() &#123;    if (tmtx.try_lock_for(std::chrono::seconds(1))) &#123;  // 尝试锁定，最多等待1秒        std::cout &lt;&lt; &quot;Lock acquired.&quot; &lt;&lt; std::endl;        tmtx.unlock();    &#125; else &#123;        std::cout &lt;&lt; &quot;Lock not acquired within timeout.&quot; &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    std::thread t1(try_lock_for_example);    std::thread t2(try_lock_for_example);    t1.join();    t2.join();    return 0;&#125;</code></pre><h3 id="std-recursive-mutex"><a href="#std-recursive-mutex" class="headerlink" title="std::recursive_mutex"></a><code>std::recursive_mutex</code></h3><p><code>std::recursive_mutex</code> 是一种递归互斥体，允许同一个线程多次锁定同一个互斥体，而不会导致死锁。每次调用 <code>lock</code> 必须有相应的 <code>unlock</code>。</p><h4 id="成员函数-2"><a href="#成员函数-2" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li><code>void lock()</code><ul><li><strong>作用</strong>: 加锁互斥体。如果互斥体已经被其他线程锁定，则调用线程将阻塞，直到互斥体变为可用。相同线程可以多次锁定互斥体。</li></ul></li></ul><pre><code class="cpp">std::recursive_mutex rmtx;rmtx.lock();rmtx.lock();  // 可以多次锁定</code></pre><ul><li><code>bool try_lock() noexcept</code><ul><li><strong>作用</strong>: 尝试锁定互斥体。如果互斥体没有被其他线程锁定或已经被当前线程锁定，则锁定并返回 <code>true</code>；如果互斥体已经被其他线程锁定，则立即返回 <code>false</code>。</li></ul></li></ul><pre><code class="cpp">if (rmtx.try_lock()) &#123;    // 成功锁定互斥体&#125; else &#123;    // 互斥体已经被其他线程锁定&#125;</code></pre><ul><li><code>void unlock()</code><ul><li><strong>作用</strong>: 解锁互斥体。如果当前线程多次锁定了互斥体，则每次调用 <code>unlock</code> 只减少一次锁定计数，直到计数归零后才真正解锁。</li></ul></li></ul><pre><code class="cpp">rmtx.unlock();rmtx.unlock();  // 必须匹配 lock 的次数</code></pre><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::recursive_mutex rmtx;void recursive_function(int count) &#123;    if (count &lt;= 0) return;    rmtx.lock();  // 可以多次锁定    std::cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; std::endl;    recursive_function(--count);    rmtx.unlock();  // 对应解锁&#125;int main() &#123;    std::thread t1(recursive_function, 3);    t1.join();    return 0;&#125;</code></pre><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong><code>std::timed_mutex</code></strong>:</p><ul><li>支持基本的锁定和解锁操作。</li><li>支持带超时的锁定操作，如 <code>try_lock_for</code> 和 <code>try_lock_until</code>。</li></ul></li><li><p><strong><code>std::recursive_mutex</code></strong>:</p><ul><li>允许同一线程多次锁定同一互斥体。</li><li>每次锁定必须有相应的解锁，确保正确管理锁计数。</li></ul></li></ul><p>这些工具在多线程编程中提供了灵活和安全的同步机制，帮助开发者有效地控制对共享资源的访问。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>C++11 提供了多种类型的互斥体和相应的锁管理工具来确保线程安全：</p><ul><li><code>std::mutex</code>：基本的互斥体类型。</li><li><code>std::lock_guard</code>：RAII 风格的互斥体管理。</li><li><code>std::unique_lock</code>：更灵活的锁管理，支持延迟锁定、超时锁定等。</li><li><code>std::timed_mutex</code>：支持带超时的锁定操作。</li><li><code>std::recursive_mutex</code>：允许同一线程多次锁定。</li></ul><p>这些工具帮助程序员更方便和安全地编写多线程程序，确保对共享资源的访问是互斥的，从而避免数据竞争和潜在的并发问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis数据库存取结构体数组数据</title>
      <link href="/2024/03/02/redis/"/>
      <url>/2024/03/02/redis/</url>
      
        <content type="html"><![CDATA[<p><code>hiredis</code> 是一个 C 语言编写的 Redis 客户端库，用于与 Redis 数据库交互。如果你想要通过 hiredis 存储和检索结构体数组的信息，你需要编写相应的 C 代码来处理这些操作。</p><p>下面我将给出一个简单的示例，展示如何使用 hiredis 在 Redis 中存储和检索结构体数组信息。我们将使用 Redis 的 <code>HMSET</code> 和 <code>HGETALL</code> 命令来处理结构体数组。</p><p>首先，让我们定义一个结构体来模拟你的需求：</p><pre><code class="c">typedef struct User &#123;    char *name;    int age;&#125; User;// 函数声明void storeUserInRedis(struct User *user, long id);void getUserFromRedis(long id, struct User *user);void printUser(const struct User *user);int main(void) &#123;    // 初始化 hiredis 和连接 Redis    redisContext *c = redisConnect(&quot;127.0.0.1&quot;, 6379);    if (c == NULL || c-&gt;err) &#123;        if (c) &#123;            printf(&quot;Error: %s\n&quot;, c-&gt;errstr);            redisFree(c);        &#125; else &#123;            printf(&quot;Connection error: can&#39;t allocate redis context\n&quot;);        &#125;        return 1;    &#125;    // 创建用户结构体    struct User fred = &#123;&quot;Fred&quot;, 25&#125;;    struct User alice = &#123;&quot;Alice&quot;, 30&#125;;    // 生成用户 ID    redisReply *reply = (redisReply *)redisCommand(c, &quot;INCR id:users&quot;);    long fred_id = reply-&gt;integer;    freeReplyObject(reply);    // 存储用户信息    storeUserInRedis(&amp;fred, fred_id);    // 再次生成用户 ID    reply = (redisReply *)redisCommand(c, &quot;INCR id:users&quot;);    long alice_id = reply-&gt;integer;    freeReplyObject(reply);    // 存储用户信息    storeUserInRedis(&amp;alice, alice_id);    // 从 Redis 中获取用户信息    struct User retrieved_user;    getUserFromRedis(fred_id, &amp;retrieved_user);    printUser(&amp;retrieved_user);    // 清理资源    redisFree(c);    free(retrieved_user.name); // 释放内存    return 0;&#125;void storeUserInRedis(struct User *user, long id) &#123;    redisReply *reply = (redisReply *)redisCommand(NULL, &quot;HMSET user:%ld name %s age %d&quot;, id, user-&gt;name, user-&gt;age);    freeReplyObject(reply);&#125;void getUserFromRedis(long id, struct User *user) &#123;    redisReply *reply = (redisReply *)redisCommand(NULL, &quot;HGETALL user:%ld&quot;, id);    if (reply-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; reply-&gt;elements &gt;= 4) &#123;        user-&gt;name = strdup(reply-&gt;element[1]-&gt;str);        user-&gt;age = atoi(reply-&gt;element[3]-&gt;str);    &#125;    freeReplyObject(reply);&#125;void printUser(const struct User *user) &#123;    printf(&quot;Name: %s, Age: %d\n&quot;, user-&gt;name, user-&gt;age);&#125;</code></pre><p>这个示例程序包含了以下几个部分：</p><ol><li><strong>定义结构体</strong>: <code>struct User</code> 包含用户的姓名和年龄。</li><li><strong>连接 Redis</strong>: 使用 <code>redisConnect</code> 连接到 Redis 服务器。</li><li><strong>生成用户 ID</strong>: 使用 <code>INCR</code> 命令递增 <code>id:users</code> 键的值。</li><li><strong>存储用户信息</strong>: 使用 <code>storeUserInRedis</code> 函数，该函数接受用户结构体和 ID 作为参数，并使用 <code>HMSET</code> 命令存储数据。</li><li><strong>获取用户信息</strong>: 使用 <code>getUserFromRedis</code> 函数，该函数接受用户 ID 和指向用户结构体的指针，使用 <code>HGETALL</code> 命令从 Redis 中获取数据并填充结构体。</li><li><strong>打印用户信息</strong>: 使用 <code>printUser</code> 函数来打印用户信息。</li></ol><p>请注意，在实际应用中你需要确保所有动态分配的内存都被正确释放，例如在 <code>getUserFromRedis</code> 函数中通过 <code>strdup</code> 分配的内存。在上面的示例中，我在 <code>main</code> 函数的最后释放了 <code>retrieved_user.name</code> 的内存。</p><p>这个示例假设你已经在 Redis 中设置了 <code>id:users</code> 键，如果没有的话，你需要先初始化它（例如通过 <code>DEL id:users</code> 和 <code>INCR id:users</code>）。此外，你需要安装 hiredis 库并且在编译时链接它。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决spawn-fcgi:child exited with:127报错</title>
      <link href="/2024/02/01/127-bao-cuo/"/>
      <url>/2024/02/01/127-bao-cuo/</url>
      
        <content type="html"><![CDATA[<p>解决spawn-fcgi:child exited with: 127报错</p><p>spawn-fcgi:child exited with: 127<br>原因：没有找到动态库</p><p>输入指令：ldd 你要运行的程序名<br>来查看缺少的库，如图我确少的是 libfcgi.so.0<br><img src="/images/1722491883237.png"></p><p>解决方案<br>先执行命令，查找所缺文件位置，比如我的（你实际操作时候一定要记住库名换成自己的，-name后面）</p><p><code>find usr/local/lib/ -name &quot;libfcgi.so&quot;</code></p><p><img src="/images/1722492061360.png"></p><p>得到库文件所在路径<code>/usr/local/lib</code></p><p>再执行<code>sudo vi /etc/ld.so.conf</code><br>在文件里添加你得到的库文件路径<code>/usr/local/lib</code>，之后保存退出</p><p><img src="/images/1722492201079.png"></p><p>最后执行<code>sudo ldconfig</code></p><p>再回到原来目录重新编译运行就成功了</p><p><img src="/images/1722492227287.png"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
