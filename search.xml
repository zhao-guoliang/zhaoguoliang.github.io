<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c++11类型强制转换</title>
      <link href="/2024/08/05/c-11-lei-xing-qiang-zhi-zhuan-huan/"/>
      <url>/2024/08/05/c-11-lei-xing-qiang-zhi-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<p>在C++中，有四种主要的强制类型转换运算符：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code> 和 <code>reinterpret_cast</code>。每种类型转换运算符在编译时或运行时执行不同的检查。</p><h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. <code>static_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于进行隐式转换和显式转换。</li><li>适用于基本数据类型之间的转换、类层次结构中的上行转换（从派生类到基类）和下行转换（从基类到派生类，但无运行时检查）。</li><li>编译器在编译时进行类型检查，确保转换是有效的。</li></ul><pre><code class="cpp">int main() &#123;    int a = 10;    double b = static_cast&lt;double&gt;(a); // 编译时转换    return 0;&#125;</code></pre><h3 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. <code>dynamic_cast</code></h3><p><strong>检测时刻：运行时</strong></p><ul><li>主要用于多态类型转换（基类指针&#x2F;引用到派生类指针&#x2F;引用）。</li><li>需要基类有至少一个虚函数，以启用运行时类型信息（RTTI）。</li><li>在运行时进行类型检查，如果转换失败，指针类型返回 <code>nullptr</code>，引用类型抛出 <code>std::bad_cast</code> 异常。</li></ul><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base &#123;public:    virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;int main() &#123;    Base* basePtr = new Derived();    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);    if (derivedPtr) &#123;        derivedPtr-&gt;derivedFunction(); // 运行时转换    &#125; else &#123;        std::cout &lt;&lt; &quot;Conversion failed&quot; &lt;&lt; std::endl;    &#125;    delete basePtr;    return 0;&#125;</code></pre><h3 id="3-const-cast"><a href="#3-const-cast" class="headerlink" title="3. const_cast"></a>3. <code>const_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于修改类型的 <code>const</code> 或 <code>volatile</code> 属性。</li><li>主要用于将 <code>const</code> 指针或引用转换为非 <code>const</code>，反之亦然。</li><li>编译器在编译时进行类型检查。</li></ul><pre><code class="cpp">int main() &#123;    const int a = 10;    int* p = const_cast&lt;int*&gt;(&amp;a); // 编译时转换    *p = 20; // 可能导致未定义行为    // 10    /*    原因：因为编译器可能会将 const 变量的值内联到代码中，因此即使修改了内存中的值，输出结果仍可能显示原始的 const 值。    */    cout&lt;&lt;a&lt;&lt;endl;    return 0;&#125;</code></pre><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. <code>reinterpret_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于进行低级别的、无类型安全检查的转换。</li><li>适用于指针类型之间的转换、将指针转换为整数类型或反之。</li><li>编译器在编译时进行类型检查，但不保证转换的安全性。</li></ul><pre><code class="cpp">int main() &#123;    int a = 10;    void* p = reinterpret_cast&lt;void*&gt;(&amp;a); // 编译时转换    int* q = reinterpret_cast&lt;int*&gt;(p);    return 0;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>static_cast</code>：编译时检测，适用于安全的类型转换，如基本数据类型和类层次结构。</li><li><code>dynamic_cast</code>：运行时检测，适用于多态类型转换，需要运行时类型检查。</li><li><code>const_cast</code>：编译时检测，适用于修改 <code>const</code> 或 <code>volatile</code> 属性。</li><li><code>reinterpret_cast</code>：编译时检测，适用于低级别、不安全的类型转换。</li></ul><p>了解这些类型转换运算符的用途和检测时刻，有助于在编写 C++ 程序时进行适当的类型转换，确保代码的安全性和正确性。</p><h3 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1.const_cast"></a>1.const_cast</h3><p><code>const_cast</code> 是 C++ 中的一个类型转换运算符，用于去除或添加指针或引用的常量性。与其他类型转换运算符不同，<code>const_cast</code> 只能用于修改类型的 <code>const</code> 或 <code>volatile</code> 属性。</p><h3 id="const-cast-基本语法"><a href="#const-cast-基本语法" class="headerlink" title="const_cast 基本语法"></a><code>const_cast</code> 基本语法</h3><pre><code class="cpp">const_cast&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型。</li><li><code>expression</code>：要转换的表达式。</li></ul><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><ol><li><strong>去除常量性</strong>：将 <code>const</code> 指针或引用转换为非 <code>const</code>，允许修改对象。</li><li><strong>添加常量性</strong>：将非 <code>const</code> 指针或引用转换为 <code>const</code>。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="去除常量性"><a href="#去除常量性" class="headerlink" title="去除常量性"></a>去除常量性</h4><pre><code class="cpp">int main() &#123;    const int n = 42;    // 将 const int* 转换为 int*    int* p = const_cast&lt;int*&gt;(&amp;n);        // 修改值，尽管这种修改可能导致未定义行为    *p = 24;        std::cout &lt;&lt; &quot;n: &quot; &lt;&lt; n &lt;&lt; std::endl;      return 0;&#125;</code></pre><h4 id="成员函数中去除常量性"><a href="#成员函数中去除常量性" class="headerlink" title="成员函数中去除常量性"></a>成员函数中去除常量性</h4><p>在某些情况下，成员函数被声明为 <code>const</code>，但是你需要修改成员变量。可以使用 <code>const_cast</code> 去除 <code>const</code> 属性。</p><pre><code class="cpp">class MyClass &#123;public:    MyClass(int val) : value(val) &#123;&#125;    void setValue(int val) const &#123;        // 去除 this 指针的常量性        const_cast&lt;MyClass*&gt;(this)-&gt;value = val;    &#125;    int getValue() const &#123;        return value;    &#125;private:    int value;&#125;;int main() &#123;    const MyClass obj(10);    obj.setValue(20);  // 修改常量对象的成员变量    std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; obj.getValue() &lt;&lt; std::endl;  // 输出 20    return 0;&#125;</code></pre><h4 id="与库函数的兼容性"><a href="#与库函数的兼容性" class="headerlink" title="与库函数的兼容性"></a>与库函数的兼容性</h4><p>有时你需要调用一个不接受 <code>const</code> 参数的旧库函数。你可以使用 <code>const_cast</code> 去除 <code>const</code> 属性来与这样的函数兼容。</p><pre><code class="cpp">void legacyFunction(char* str) &#123;    std::cout &lt;&lt; &quot;Legacy function: &quot; &lt;&lt; str &lt;&lt; std::endl;&#125;int main() &#123;    const char* text = &quot;Hello, world!&quot;;    // 将 const char* 转换为 char*    legacyFunction(const_cast&lt;char*&gt;(text));    return 0;&#125;</code></pre><h3 id="添加常量性"><a href="#添加常量性" class="headerlink" title="添加常量性"></a>添加常量性</h3><p>虽然不常见，但也可以使用 <code>const_cast</code> 添加常量性。</p><pre><code class="cpp">int main() &#123;    int n = 42;    // 将 int* 转换为 const int*    const int* p = const_cast&lt;const int*&gt;(&amp;n);    // 现在 p 是一个 const int*，不能通过它修改 n    // *p = 24;  // 错误，不能修改    return 0;&#125;</code></pre><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><p><strong>未定义行为</strong>：通过 <code>const_cast</code> 去除常量性并修改对象，如果对象本身是常量的（例如，定义为 <code>const</code>），这种修改会导致未定义行为。</p><pre><code class="cpp">const int n = 42;int* p = const_cast&lt;int*&gt;(&amp;n);*p = 24;  </code></pre></li><li><p><strong>设计意图</strong>：<code>const_cast</code> 应该仅用于你确定不会破坏代码逻辑和设计意图的情况下。常量性通常用于保护数据不被意外修改，因此应谨慎使用 <code>const_cast</code>。</p></li><li><p><strong>兼容性</strong>：<code>const_cast</code> 的主要用途是为了与旧的、不使用 <code>const</code> 修饰的代码或库进行兼容。在新的代码中，尽量避免使用 <code>const_cast</code>，并采用更为安全的设计。</p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>const_cast</code> 是一个功能强大的类型转换工具，用于在 C++ 中处理 <code>const</code> 和 <code>volatile</code> 属性。尽管它在某些场景下非常有用，但由于可能引发未定义行为，因此应谨慎使用，并尽量在设计时避免需要使用它的情况。</p><h3 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2.static_cast"></a>2.static_cast</h3><p><code>static_cast</code> 是 C++ 中的一种类型转换运算符，用于在编译时执行类型转换。与 <code>reinterpret_cast</code> 和 <code>const_cast</code> 不同，<code>static_cast</code> 更加安全，因为它只能在特定类型之间进行转换，并且在编译时进行检查。它适用于以下几种常见的类型转换场景：</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="cpp">static_cast&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型。</li><li><code>expression</code>：要转换的表达式。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p><strong>基本数据类型之间的转换</strong>：</p><pre><code class="cpp">int main() &#123;    float f = 3.14;    int i = static_cast&lt;int&gt;(f);  // 将 float 转换为 int    std::cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; std::endl;  // 输出 i: 3    return 0;&#125;</code></pre></li><li><p><strong>指针类型之间的转换</strong>：</p><pre><code class="cpp">class Base &#123;&#125;;class Derived : public Base &#123;&#125;;int main() &#123;    Derived d;    Base* b = static_cast&lt;Base*&gt;(&amp;d);  // 将 Derived* 转换为 Base*    return 0;&#125;</code></pre></li><li><p><strong>将空指针转换为其他指针类型</strong>：</p><pre><code class="cpp">int main() &#123;    void* ptr = nullptr;    int* intPtr = static_cast&lt;int*&gt;(ptr);  // 将 void* 转换为 int*    return 0;&#125;</code></pre></li><li><p><strong>转换枚举类型</strong>：</p><pre><code class="cpp">enum Color &#123; RED, GREEN, BLUE &#125;;int main() &#123;    Color c = RED;    int colorInt = static_cast&lt;int&gt;(c);  // 将枚举类型转换为 int    std::cout &lt;&lt; &quot;colorInt: &quot; &lt;&lt; colorInt &lt;&lt; std::endl;  // 输出 colorInt: 0    return 0;&#125;</code></pre></li><li><p><strong>基础类和派生类之间的转换</strong>：</p><pre><code class="cpp">class Base &#123;public:    virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;&#125;&#125;;int main() &#123;    Base* b = new Derived();    Derived* d = static_cast&lt;Derived*&gt;(b);  // 将 Base* 转换为 Derived*    d-&gt;derivedFunction();  // 调用派生类的方法    delete b;    return 0;&#125;</code></pre></li><li><p><strong>有意义的类型转换运算符</strong>：</p><pre><code class="cpp">class Complex &#123;public:    Complex(double real, double imag) : real(real), imag(imag) &#123;&#125;    // 定义转换运算符，将 Complex 转换为 double    operator double() const &#123;        return real;    &#125;private:    double real;    double imag;&#125;;int main() &#123;    Complex c(3.0, 4.0);    double realPart = static_cast&lt;double&gt;(c);  // 使用转换运算符将 Complex 转换为 double    std::cout &lt;&lt; &quot;realPart: &quot; &lt;&lt; realPart &lt;&lt; std::endl;  // 输出 realPart: 3.0    return 0;&#125;</code></pre></li></ol><h3 id="使用注意事项-1"><a href="#使用注意事项-1" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><p><strong>安全性</strong>：<code>static_cast</code> 进行的是编译时检查，因此相对于 <code>reinterpret_cast</code> 更为安全。但它不能用于去除 <code>const</code>、<code>volatile</code> 限定符，也不能进行不相关类型的转换。</p></li><li><p><strong>适用场景</strong>：适用于基本数据类型、指针类型、枚举类型、类层次结构中的上行转换和下行转换（必须确保安全下行）。</p></li><li><p><strong>避免未定义行为</strong>：在进行基类和派生类之间的转换时，必须确保转换是安全的，即被转换对象实际是派生类类型，否则会导致未定义行为。</p></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>static_cast</code> 是 C++ 中一种安全且常用的类型转换运算符，适用于多种类型转换场景。它在编译时进行类型检查，相比 <code>reinterpret_cast</code> 和 <code>const_cast</code> 更加安全可靠。在使用时，确保理解转换的类型和语义，以避免潜在的未定义行为。</p><p><code>dynamic_cast</code> 是 C++ 中的一种类型转换运算符，用于在运行时进行安全的类型转换。它主要用于处理继承层次结构中的指针或引用，特别是在多态（polymorphism）情况下。<code>dynamic_cast</code> 通过运行时类型检查（RTTI, Run-Time Type Information）来确保转换的安全性。如果转换失败，指针类型会返回 <code>nullptr</code>，引用类型会抛出 <code>std::bad_cast</code> 异常。</p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="cpp">dynamic_cast&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型，必须是一个指针或引用类型。</li><li><code>expression</code>：要转换的表达式，通常是一个指向基类的指针或引用。</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>向下转换（Downcasting）</strong>：将基类指针或引用转换为派生类指针或引用。</li><li><strong>横向转换（Sidecasting）</strong>：在有多重继承的情况下，从一个基类指针转换为另一个基类指针。</li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="向下转换"><a href="#向下转换" class="headerlink" title="向下转换"></a>向下转换</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base &#123;public:    virtual ~Base() &#123;&#125;  // 必须有虚函数以启用 RTTI&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;int main() &#123;    Base* basePtr = new Derived();  // 基类指针指向派生类对象    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);    if (derivedPtr) &#123;        derivedPtr-&gt;derivedFunction();  // 安全调用派生类函数    &#125; else &#123;        std::cout &lt;&lt; &quot;Conversion failed&quot; &lt;&lt; std::endl;    &#125;    delete basePtr;    return 0;&#125;</code></pre><h4 id="横向转换"><a href="#横向转换" class="headerlink" title="横向转换"></a>横向转换</h4><pre><code class="cpp">#include &lt;iostream&gt;class Base1 &#123;public:    virtual ~Base1() &#123;&#125;&#125;;class Base2 &#123;public:    virtual ~Base2() &#123;&#125;&#125;;class Derived : public Base1, public Base2 &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;int main() &#123;    Base1* base1Ptr = new Derived();  // Base1 指针指向 Derived 对象    Base2* base2Ptr = dynamic_cast&lt;Base2*&gt;(base1Ptr);    if (base2Ptr) &#123;        std::cout &lt;&lt; &quot;Successfully cast Base1* to Base2*&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;Conversion failed&quot; &lt;&lt; std::endl;    &#125;    delete base1Ptr;    return 0;&#125;</code></pre><h4 id="引用类型的转换"><a href="#引用类型的转换" class="headerlink" title="引用类型的转换"></a>引用类型的转换</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base &#123;public:    virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public:    void derivedFunction() &#123;        std::cout &lt;&lt; &quot;Derived function called&quot; &lt;&lt; std::endl;    &#125;&#125;;void process(Base&amp; baseRef) &#123;    try &#123;        Derived&amp; derivedRef = dynamic_cast&lt;Derived&amp;&gt;(baseRef);        derivedRef.derivedFunction();    &#125; catch (const std::bad_cast&amp; e) &#123;        std::cerr &lt;&lt; &quot;Bad cast: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    Derived derivedObj;    Base&amp; baseRef = derivedObj;    process(baseRef);  // 安全转换并调用派生类方法    return 0;&#125;</code></pre><h3 id="使用注意事项-2"><a href="#使用注意事项-2" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol><li><strong>必须有虚函数</strong>：基类必须有至少一个虚函数，以便启用运行时类型信息（RTTI）。</li><li><strong>转换失败处理</strong>：在使用指针类型时，转换失败会返回 <code>nullptr</code>，在使用引用类型时，转换失败会抛出 <code>std::bad_cast</code> 异常。</li><li><strong>性能考虑</strong>：<code>dynamic_cast</code> 在运行时进行类型检查，因此相对于 <code>static_cast</code> 有一定的性能开销。</li><li><strong>避免不必要的转换</strong>：尽量设计代码避免频繁使用 <code>dynamic_cast</code>，如果可能，使用更优雅的设计模式，如策略模式或访问者模式。</li></ol><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><code>dynamic_cast</code> 是一个强大的工具，用于在 C++ 中处理继承层次结构中的类型安全转换。它通过运行时类型检查来确保转换的安全性，适用于向下转换和横向转换。理解和正确使用 <code>dynamic_cast</code> 可以帮助你编写更加健壮和安全的面向对象代码。</p><h3 id="4-reinterpret-cast-1"><a href="#4-reinterpret-cast-1" class="headerlink" title="4.reinterpret_cast"></a>4.reinterpret_cast</h3><p><code>reinterpret_cast</code> 是 C++ 中的一种类型转换运算符，用于强制转换指针、引用和其他类型之间。与其他类型转换运算符（如 <code>static_cast</code>、<code>dynamic_cast</code> 和 <code>const_cast</code>）不同，<code>reinterpret_cast</code> 可以执行非常规的类型转换，包括不安全的和未定义行为的转换，因此使用时需要特别小心。</p><h3 id="使用场景和示例"><a href="#使用场景和示例" class="headerlink" title="使用场景和示例"></a>使用场景和示例</h3><ol><li><p><strong>指针类型之间的转换</strong>：</p><pre><code class="cpp">int main() &#123;    int n = 42;    // 将 int* 转换为 char*    char* p = reinterpret_cast&lt;char*&gt;(&amp;n);    // 输出指针 p 所指向的值    std::cout &lt;&lt; *p &lt;&lt; std::endl;  // 注意：输出的值依赖于系统的字节序和类型大小    return 0;&#125;</code></pre></li><li><p><strong>将整数转换为指针类型</strong>：</p><pre><code class="cpp">int main() &#123;    intptr_t addr = 0x12345678;  // 整数地址    // 将整数转换为指针    int* p = reinterpret_cast&lt;int*&gt;(addr);    // 打印指针地址    std::cout &lt;&lt; p &lt;&lt; std::endl;    return 0;&#125;</code></pre></li><li><p><strong>将指针转换为整数类型</strong>：</p><pre><code class="cpp">int main() &#123;    int n = 42;    int* p = &amp;n;    // 将指针转换为整数    intptr_t addr = reinterpret_cast&lt;intptr_t&gt;(p);    // 打印整数地址    std::cout &lt;&lt; std::hex &lt;&lt; addr &lt;&lt; std::endl;    return 0;&#125;</code></pre></li><li><p><strong>指向对象的指针转换为指向不同类型对象的指针</strong>：</p><pre><code class="cpp">struct A &#123;    int x;&#125;;struct B &#123;    int y;&#125;;int main() &#123;    A a;    a.x = 10;    // 将 A* 转换为 B*    B* b = reinterpret_cast&lt;B*&gt;(&amp;a);    // 注意：访问 b-&gt;y 是不安全的，因为它不是 B 对象    std::cout &lt;&lt; b-&gt;y &lt;&lt; std::endl;  // 未定义行为    return 0;&#125;</code></pre></li></ol><h3 id="使用注意事项-3"><a href="#使用注意事项-3" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><strong>不安全</strong>：<code>reinterpret_cast</code> 可以执行不安全的转换，这可能导致未定义行为。</li><li><strong>可移植性</strong>：<code>reinterpret_cast</code> 的行为可能依赖于具体的编译器和平台，因此使用时要考虑代码的可移植性。</li><li><strong>用途有限</strong>：应该尽量减少使用 <code>reinterpret_cast</code>，除非确实需要进行底层的、特定的类型转换，且确定不会导致未定义行为。</li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>reinterpret_cast</code> 是一种功能强大但危险的类型转换运算符，主要用于需要底层操作的场景。使用时应确保转换是合理且安全的，以避免潜在的未定义行为和难以调试的问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++的const</title>
      <link href="/2024/08/05/c-de-const/"/>
      <url>/2024/08/05/c-de-const/</url>
      
        <content type="html"><![CDATA[<h1 id="C-const-关键字小结"><a href="#C-const-关键字小结" class="headerlink" title="C++ const 关键字小结"></a>C++ <code>const</code> 关键字小结</h1><p><code>const</code> 是 constant 的缩写，本意是不变的、不易改变的意思。在 C++ 中，</p><p><code>const</code> 用来修饰内置类型变量、自定义对象、成员函数、返回值、函数参数。</p><h2 id="1-C语言的-const-特点"><a href="#1-C语言的-const-特点" class="headerlink" title="1. C语言的 const 特点"></a>1. C语言的 <code>const</code> 特点</h2><p>const int a &#x3D; 10; &#x2F;&#x2F; 不要把a看成常量<br>&#x2F;&#x2F; a的本质是变量，只是只读变量</p><p>C语言的 <code>const</code> 修饰全局变量默认是（外部链接的）。</p><h3 id="fun-c"><a href="#fun-c" class="headerlink" title="fun.c"></a>fun.c</h3><pre><code class="cpp">// C语言的const修饰全局变量默认是（外部链接的）// 外部链接: 其他源文件可以使用const int num = 100; // 只读的全局变量，内存放在文字常量区（内存空间只读）</code></pre><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><pre><code class="cpp">// 对fun.c中的num进行声明(不要赋值)extern const int num;void test03() &#123;    printf(&quot;num = %d\n&quot;, num);    // num = 200; // err num只读    // C语言中const修饰变量名，说明变量名为只读（用户不能通过变量名data进行赋值）    const int data = 100; // 局部只读变量，内存在栈区（内存可读可写）    // data = 200; // err    printf(&quot;data = %d\n&quot;, data);    // 但是：如果知道data的地址，可以通过地址间接地修改data所对应空间的内容    int *p = (int *)&amp;data;    *p = 2000;    printf(&quot;data = %d\n&quot;, data); // ok 2000&#125;</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li><code>const</code> 修饰全局变量 <code>num</code>，变量名只读，内存空间在文字常量区（只读），不能通过 <code>num</code> 的地址修改空间内容。</li><li><code>const</code> 修饰局部变量 <code>data</code>，变量名只读，内存空间在栈区（可读可写），可以通过 <code>data</code> 地址间接地修改空间内容。</li></ol><h2 id="2-C-中的-const-深入理解"><a href="#2-C-中的-const-深入理解" class="headerlink" title="2. C++中的 const 深入理解"></a>2. C++中的 <code>const</code> 深入理解</h2><p><img src="/images/v2-cfd0b188ea87aeb4eed52737f45697b9_r.jpg"></p><h3 id="fun-cpp"><a href="#fun-cpp" class="headerlink" title="fun.cpp"></a>fun.cpp</h3><pre><code class="cpp">// const修饰的全局变量默认是内部链接（只在当前源文件有效，不能直接用于其他源文件）// const int num = 100;// 如果必须用在其他源文件使用只读的全局变量，必须加 extern 将 num 转换成外部链接extern const int num = 100;</code></pre><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><pre><code class="cpp">// 声明extern const int num;struct Person &#123;    int num;    char name[32];&#125;;void test04() &#123;    cout &lt;&lt; &quot;全局num = &quot; &lt;&lt; num &lt;&lt; endl; // err 不识别num    // 1. C++中，对于基础类型，系统不会给data开辟空间，data放到符号表中    const int data = 10;    // data = 100; // err 只读    cout &lt;&lt; &quot;data = &quot; &lt;&lt; data &lt;&lt; endl;    // 2. C++中当对data取地址的时候，系统就会给data开辟空间    int *p = (int *)&amp;data;    *p = 2000;    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; // 空间内容修改成功 2000    cout &lt;&lt; &quot;data = &quot; &lt;&lt; data &lt;&lt; endl; // data 还是10，为啥？    // 2. 当以变量的形式初始化const修饰的变量，系统会为其开辟空间    int b = 200;    const int a = b; // 系统直接为a开辟空间，而不会把a放入符号表中    p = (int *)&amp;a;    *p = 3000;    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; // 3000    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // 3000    // 3. const修饰自定义数据类型（结构体、对象），系统会分配空间    const Person per = &#123;100, &quot;lucy&quot;&#125;;    // per.num = 1000; // err    cout &lt;&lt; &quot;num = &quot; &lt;&lt; per.num &lt;&lt; &quot;, name = &quot; &lt;&lt; per.name &lt;&lt; endl; // 100 lucy    Person *p1 = (Person *)&amp;per;    p1-&gt;num = 2000;    cout &lt;&lt; &quot;num = &quot; &lt;&lt; per.num &lt;&lt; &quot;, name = &quot; &lt;&lt; per.name &lt;&lt; endl; // 2000 lucy&#125;</code></pre><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="/%5Cimages%5CSnipaste_2024-08-05_22-41-30.png"></p><p>C++的<code>const</code>总结：</p><ol><li><code>const int data = 10;</code> &#x2F;&#x2F; data先放入符号表</li><li>如果对data取地址，系统才会给data开辟空间</li><li><code>const int a = b;</code> &#x2F;&#x2F; b是变量名，系统直接给a开辟空间，而不放入符号表</li><li><code>const</code> 修饰自定义数据，系统为自定义数据开辟空间</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cmp报错</title>
      <link href="/2024/08/05/cmp-bao-cuo/"/>
      <url>/2024/08/05/cmp-bao-cuo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性</title>
      <link href="/2024/08/05/c-11-xin-te-xing/"/>
      <url>/2024/08/05/c-11-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="共享智能指针"><a href="#共享智能指针" class="headerlink" title="共享智能指针"></a>共享智能指针</h3><h3 id="1-shared-ptr的初始化"><a href="#1-shared-ptr的初始化" class="headerlink" title="1.shared_ptr的初始化"></a>1.shared_ptr的初始化</h3><p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针<code>shared_ptr</code> 是一个模板类，如果要进行初始化有三种方式：通过<strong>构造函数</strong>、<strong>make_shared辅助函数</strong>以及<strong>reset方法</strong>。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数<code>use_count</code>，函数原型如下：</p><pre><code class="c++">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。long use_count() const noexcept;</code></pre><h5 id="1-1-构造函数初始化"><a href="#1-1-构造函数初始化" class="headerlink" title="1.1 构造函数初始化"></a>1.1 构造函数初始化</h5><p>shared_ptr<T> 类模板中，提供了多种实用的构造函数, 语法格式如下:<br>shared_ptr<T> 智能指针名字(创建堆内存);</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存    shared_ptr&lt;int&gt; ptr1(new int(520));    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;        // 使用智能指针管理一块字符数组对应的堆内存    shared_ptr&lt;char&gt; ptr2(new char[12]);    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;        // 创建智能指针对象, 不管理任何内存    shared_ptr&lt;int&gt; ptr3;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;        // 创建智能指针对象, 初始化为空    shared_ptr&lt;int&gt; ptr4(nullptr);    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    return 0;&#125;</code></pre><p>测试代码输出的结果如下:</p><p>ptr1管理的内存引用计数: 1<br>ptr2管理的内存引用计数: 1<br>ptr3管理的内存引用计数: 0<br>ptr4管理的内存引用计数: 0</p><p>如果智能指针被初始化了一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为<code>nullptr</code>空指针，引用计数不会+1。另外，不要使用一个原始指针初始化多个<code>shared_ptr</code>。</p><pre><code class="c++">int *p = new int;shared_ptr&lt;int&gt; p1(p);    //原始指针只能吃初始化一个智能指针shared_ptr&lt;int&gt; p2(p);// error, 编译不会报错, 运行会出错</code></pre><h5 id="1-2-通过拷贝和移动构造函数初始化"><a href="#1-2-通过拷贝和移动构造函数初始化" class="headerlink" title="1.2 通过拷贝和移动构造函数初始化"></a>1.2 通过拷贝和移动构造函数初始化</h5><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1    shared_ptr&lt;int&gt; ptr1(new int(520));    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;        //调用拷贝构造函数    shared_ptr&lt;int&gt; ptr2(ptr1);    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    shared_ptr&lt;int&gt; ptr3 = ptr1;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;        //调用移动构造函数    shared_ptr&lt;int&gt; ptr4(move(ptr1));    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    std::shared_ptr&lt;int&gt; ptr5 = move(ptr2);    cout &lt;&lt; &quot;ptr5管理的内存引用计数: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;        return 0;&#125;</code></pre><p>测试程序输入的结果：<br>ptr1管理的内存引用计数: 1<br>ptr2管理的内存引用计数: 2<br>ptr3管理的内存引用计数: 3<br>ptr4管理的内存引用计数: 3<br>ptr5管理的内存引用计数: 3</p><p>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。</p><h5 id="1-3-通过make-shared初始化"><a href="#1-3-通过make-shared初始化" class="headerlink" title="1.3 通过make_shared初始化"></a>1.3 通过make_shared初始化</h5><p>通过C++提供的make_shared() 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p><pre><code class="c++">template&lt; class T, class... Args &gt;shared_ptr&lt;T&gt; make_shared( Args&amp;&amp;... args );//T：模板参数的数据类型//Args&amp;&amp;... args ：要初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定</code></pre><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;class Test&#123;public:    Test()     &#123;        cout &lt;&lt; &quot;construct Test...&quot; &lt;&lt; endl;    &#125;    Test(int x)     &#123;        cout &lt;&lt; &quot;construct Test, x = &quot; &lt;&lt; x &lt;&lt; endl;    &#125;    Test(string str)     &#123;        cout &lt;&lt; &quot;construct Test, str = &quot; &lt;&lt; str &lt;&lt; endl;    &#125;    ~Test()    &#123;        cout &lt;&lt; &quot;destruct Test ...&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1    shared_ptr&lt;int&gt; ptr1 = make_shared&lt;int&gt;(520);    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;    shared_ptr&lt;Test&gt; ptr2 = make_shared&lt;Test&gt;();    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    shared_ptr&lt;Test&gt; ptr3 = make_shared&lt;Test&gt;(520);    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;    shared_ptr&lt;Test&gt; ptr4 = make_shared&lt;Test&gt;(&quot;我是要成为海贼王的男人!!!&quot;);    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    return 0;&#125;</code></pre><p>使用std::make_shared()模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。</p><h5 id="1-4-通过-reset方法初始化"><a href="#1-4-通过-reset方法初始化" class="headerlink" title="1.4 通过 reset方法初始化"></a>1.4 通过 reset方法初始化</h5><p>共享智能指针类提供的std::shared_ptr::reset方法函数原型如下：</p><pre><code class="c++">void reset() noexcept;template&lt; class Y &gt;void reset( Y* ptr );template&lt; class Y, class Deleter &gt;void reset( Y* ptr, Deleter d );template&lt; class Y, class Deleter, class Alloc &gt;void reset( Y* ptr, Deleter d, Alloc alloc );</code></pre><p>ptr：指向要取得所有权的对象的指针<br>d：指向要取得所有权的对象的指针<br>aloc：内部存储所用的分配器</p><p>测试代码如下：</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1    shared_ptr&lt;int&gt; ptr1 = make_shared&lt;int&gt;(520);    shared_ptr&lt;int&gt; ptr2 = ptr1;    shared_ptr&lt;int&gt; ptr3 = ptr1;    shared_ptr&lt;int&gt; ptr4 = ptr1;    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;    ptr4.reset();    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;        shared_ptr&lt;int&gt; ptr5;    ptr5.reset(new int(250));    cout &lt;&lt; &quot;ptr5管理的内存引用计数: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;        return 0;&#125;</code></pre><p>测试代码输入的结果:</p><p>ptr1管理的内存引用计数: 4<br>ptr2管理的内存引用计数: 4<br>ptr3管理的内存引用计数: 4<br>ptr4管理的内存引用计数: 4</p><p>ptr1管理的内存引用计数: 3<br>ptr2管理的内存引用计数: 3<br>ptr3管理的内存引用计数: 3<br>ptr4管理的内存引用计数: 0</p><p>ptr5管理的内存引用计数: 1</p><p><strong>对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。</strong></p><h5 id="1-5-获取原始指针"><a href="#1-5-获取原始指针" class="headerlink" title="1.5 获取原始指针"></a>1.5 获取原始指针</h5><p>通过智能指针可以管理一个普通变量或者对象的地址，此时原始地址就不可见了。当我们想要修改变量或者对象中的值的时候，就需要从智能指针对象中先取出数据的原始内存的地址再操作，解决方案是调用共享智能指针类提供的get()方法，其函数原型如下：</p><p><code>T* get() const noexcept;</code></p><p>测试代码如下:</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    int len = 128;    shared_ptr&lt;char&gt; ptr(new char[len]);        // 得到指针的原始地址    char* add = ptr.get();    memset(add, 0, len);    strcpy(add, &quot;我是要成为海贼王的男人!!!&quot;);    cout &lt;&lt; &quot;string: &quot; &lt;&lt; add &lt;&lt; endl;        shared_ptr&lt;int&gt; p(new int);    *p = 100;    cout &lt;&lt; *p.get() &lt;&lt; &quot;  &quot; &lt;&lt; *p &lt;&lt; endl;        return 0;&#125;</code></pre><h3 id="指定删除器"><a href="#指定删除器" class="headerlink" title="指定删除器"></a>指定删除器</h3><p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;// 自定义删除器函数，释放int型内存void deleteIntPtr(int* p)&#123;    delete p;    cout &lt;&lt; &quot;int 型内存被释放了...&quot;;&#125;int main()&#123;    shared_ptr&lt;int&gt; ptr(new int(250), deleteIntPtr);    return 0;&#125;//删除器函数也可以是lambda表达式，因此代码也可以写成下面这样：int main()&#123;    shared_ptr&lt;int&gt; ptr(new int(250), [](int* p) &#123;delete p; &#125;);    return 0;&#125;</code></pre><p>在上面的代码中，lambda表达式的参数就是智能指针管理的内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。</p><p>在C++11中使用<code>shared_ptr</code>管理动态数组时，需要指定删除器，因为<code>shared_ptr</code>的<em>默认删除器不支持数组对象</em>，具体的处理代码如下：</p><pre><code class="c++">int main()&#123;    shared_ptr&lt;int&gt; ptr(new int[10], [](int* p) &#123;delete[]p; &#125;);    return 0;&#125;/*在删除数组内存时，除了自己编写删除器，也可以使用C++提供的default_delete&lt;T&gt;()函数作为删除器，这个函数内部的删除功能也是通过调用delete来实现的，要释放什么类型的内存就将模板类型T指定为什么类型即可。具体处理代码如下：*/int main()&#123;    shared_ptr&lt;int&gt; ptr(new int[10], default_delete&lt;int[]&gt;());    return 0;&#125;</code></pre><p>另外，我们还可以自己封装一个<code>make_shared_array</code>方法来让<code>shared_ptr</code>支持数组，代码如下:</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;template &lt;typename T&gt;shared_ptr&lt;T&gt; make_share_array(size_t size)&#123;    // 返回匿名对象    return shared_ptr&lt;T&gt;(new T[size], default_delete&lt;T[]&gt;());&#125;int main()&#123;    shared_ptr&lt;int&gt; ptr1 = make_share_array&lt;int&gt;(10);    cout &lt;&lt; ptr1.use_count() &lt;&lt; endl;    shared_ptr&lt;char&gt; ptr2 = make_share_array&lt;char&gt;(128);    cout &lt;&lt; ptr2.use_count() &lt;&lt; endl;    return 0;&#125;</code></pre><p><code>shared_ptr</code>使用注意事项:</p><p>1.不能使用一个原始地址初始化多个共享智能指针。</p><p>2.函数不能返回管理了this的共享智能指针对象。</p><p>3.共享智能指针不能循环引用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消息验证码和数字签名</title>
      <link href="/2024/07/29/xiao-xi-yan-zheng-ma-he-shu-zi-qian-ming/"/>
      <url>/2024/07/29/xiao-xi-yan-zheng-ma-he-shu-zi-qian-ming/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/07/29/she-ji-mo-shi/"/>
      <url>/2024/07/29/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<p><strong>工厂设计模式</strong></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std; // 引入 std 命名空间// 抽象产品类class Product &#123;public:    virtual void display() = 0;    virtual ~Product() &#123;&#125;&#125;;// 具体产品类 Aclass ConcreteProductA : public Product &#123;public:    void display() override &#123;        cout &lt;&lt; &quot;Concrete Product A&quot; &lt;&lt; endl;    &#125;&#125;;// 具体产品类 Bclass ConcreteProductB : public Product &#123;public:    void display() override &#123;        cout &lt;&lt; &quot;Concrete Product B&quot; &lt;&lt; endl;    &#125;&#125;;// 工厂类class Factory &#123;public:    // 静态方法，根据参数创建具体产品对象    static unique_ptr&lt;Product&gt; createProduct(char type) &#123;        switch (type) &#123;            case &#39;A&#39;:                return make_unique&lt;ConcreteProductA&gt;();            case &#39;B&#39;:                return make_unique&lt;ConcreteProductB&gt;();            default:                return nullptr;        &#125;    &#125;&#125;;int main() &#123;    // 使用工厂创建具体产品 A    unique_ptr&lt;Product&gt; productA = Factory::createProduct(&#39;A&#39;);    if (productA) &#123;        productA-&gt;display();    &#125;    // 使用工厂创建具体产品 B    unique_ptr&lt;Product&gt; productB = Factory::createProduct(&#39;B&#39;);    if (productB) &#123;        productB-&gt;display();    &#125;    // 使用工厂创建不存在的产品    unique_ptr&lt;Product&gt; productC = Factory::createProduct(&#39;C&#39;);    if (!productC) &#123;        cout &lt;&lt; &quot;Invalid product type requested.&quot; &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux配置环境变量</title>
      <link href="/2024/07/26/linux-pei-zhi-huan-jing-bian-liang/"/>
      <url>/2024/07/26/linux-pei-zhi-huan-jing-bian-liang/</url>
      
        <content type="html"><![CDATA[<p>当你在终端中输入 <code>echo $PATH</code> 并按回车，你会看到一系列由冒号分隔的目录路径。<code>$PATH</code> 是一个环境变量，它告诉你的系统在哪里查找可执行命令。每当你在终端输入一个命令，系统就会在 <code>$PATH</code> 变量列出的目录中搜索对应的可执行文件。</p><p><code>$PATH</code> 变量的值通常包括以下目录：</p><ul><li><code>/usr/local/bin</code>: 用户安装的本地应用程序的可执行文件。</li><li><code>/usr/bin</code>: 系统提供的标准应用程序。</li><li><code>/bin</code>: 基础的系统命令。</li><li><code>/usr/sbin</code>: 系统管理员使用的系统命令。</li><li><code>/sbin</code>: 基础的系统管理命令。</li><li><code>~/bin</code>: 用户个人的可执行文件目录。</li><li><code>/usr/local/sbin</code>: 类似于 <code>/usr/local/bin</code>，但用于系统管理命令。</li></ul><p>例如，<code>$PATH</code> 的输出可能类似于：</p><p><strong>&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:~&#x2F;bin</strong></p><p>这意味着当你在终端中输入 <code>ls</code>、<code>cd</code> 或任何其他命令时，系统会在这些目录中查找匹配的可执行文件。</p><p>你可以通过以下步骤将 &#x2F;usr&#x2F;local&#x2F;lib 添加到 PATH 环境变量中：<br>打开终端。<br>使用以下命令将 &#x2F;usr&#x2F;local&#x2F;lib 添加到当前会话的 PATH 环境变量：<br><code>export PATH=$PATH:/usr/local/lib</code><br>这只会在当前终端会话中生效。如果你关闭终端，设置将会丢失。</p><p>如果你希望永久性地将 &#x2F;usr&#x2F;local&#x2F;lib 添加到 PATH 环境变量中，你需要将上述命令添加到你的 shell 配置文件中。具体步骤如下：<br>对于 bash，编辑 ~&#x2F;.bashrc 文件：<br><code>echo &#39;export PATH=$PATH:/usr/local/lib&#39; &gt;&gt; ~/.bashrc</code></p><p>使配置文件生效：</p><p><code>source ~/.bashrc</code></p><p>这样，&#x2F;usr&#x2F;local&#x2F;lib 将被永久添加到 PATH 环境变量中，并在你每次打开新的终端会话时生效。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11互斥体</title>
      <link href="/2024/05/06/c-11-hu-chi-ti/"/>
      <url>/2024/05/06/c-11-hu-chi-ti/</url>
      
        <content type="html"><![CDATA[<p>C++11引入了许多新特性来支持多线程编程，其中包括互斥体（mutex）和其他同步机制。互斥体提供了一种机制，用于<strong>确保多个线程在同一时刻不会访问共享资源 ，从而避免数据竞争。</strong>下面是对C++11互斥体的详细介绍。</p><h3 id="1-std-mutex"><a href="#1-std-mutex" class="headerlink" title="1. std::mutex"></a>1. <code>std::mutex</code></h3><p><code>std::mutex</code> 是最基本的互斥体类型，用于保护共享数据，以防止多个线程同时访问。互斥体可以显式地加锁和解锁。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;mutex mtx;void print_thread_id(int id) &#123;    mtx.lock();    cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;    mtx.unlock();&#125;int main() &#123;    thread t1(print_thread_id, 1);    thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>在这个例子中，<code>mtx.lock()</code> 和 <code>mtx.unlock()</code> 确保了只有一个线程能够在同一时刻访问共享资源。</p><h3 id="2-std-lock-guard"><a href="#2-std-lock-guard" class="headerlink" title="2. std::lock_guard"></a>2. <code>std::lock_guard</code></h3><p><code>std::lock_guard</code> 是一种方便的 RAII 机制，用于<strong>自动管理互斥体的锁定和解锁</strong>。<strong>它在构造时锁定互斥体，在析构时解锁互斥体，确保互斥体在作用域结束时总是被解锁。</strong></p><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;void print_thread_id(int id) &#123;    std::lock_guard&lt;std::mutex&gt; lock(mtx);    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>在这个例子中，<code>std::lock_guard</code> 确保了 <code>mtx</code> 在函数 <code>print_thread_id</code> 中的整个作用域内都是锁定的。</p><h3 id="3-std-unique-lock"><a href="#3-std-unique-lock" class="headerlink" title="3. std::unique_lock"></a>3. <code>std::unique_lock</code></h3><p><code>std::unique_lock</code> 是一种更灵活的互斥体锁管理器。与 <code>std::lock_guard</code> 相比，<code>std::unique_lock</code> 支持<strong>延迟锁定、锁定超时和锁的解锁&#x2F;重新锁定。</strong></p><h4 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;void print_thread_id(int id) &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx);    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><h4 id="延迟锁定和手动锁定-解锁"><a href="#延迟锁定和手动锁定-解锁" class="headerlink" title="延迟锁定和手动锁定&#x2F;解锁"></a>延迟锁定和手动锁定&#x2F;解锁</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;void print_thread_id(int id) &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx, std::defer_lock); // 延迟锁定    // 其他操作    lock.lock(); // 手动锁定    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; std::endl;    lock.unlock(); // 手动解锁    // 其他操作&#125;int main() &#123;    std::thread t1(print_thread_id, 1);    std::thread t2(print_thread_id, 2);    t1.join();    t2.join();    return 0;&#125;</code></pre><h4 id="带超时的锁定"><a href="#带超时的锁定" class="headerlink" title="带超时的锁定"></a>带超时的锁定</h4><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;std::mutex mtx;void try_lock_for_example() &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx, std::try_to_lock);    if (lock.owns_lock()) &#123;        std::cout &lt;&lt; &quot;Lock acquired.&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;Lock not acquired.&quot; &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    std::thread t1(try_lock_for_example);    std::thread t2(try_lock_for_example);    t1.join();    t2.join();    return 0;&#125;</code></pre><h3 id="4-std-timed-mutex-和-std-recursive-mutex"><a href="#4-std-timed-mutex-和-std-recursive-mutex" class="headerlink" title="4. std::timed_mutex 和 std::recursive_mutex"></a>4. <code>std::timed_mutex</code> 和 <code>std::recursive_mutex</code></h3><h4 id="std-timed-mutex"><a href="#std-timed-mutex" class="headerlink" title="std::timed_mutex"></a><code>std::timed_mutex</code></h4><p><code>std::timed_mutex</code> 支持带超时的锁定操作。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;std::timed_mutex tmtx;void try_lock_for_example() &#123;    if (tmtx.try_lock_for(std::chrono::seconds(1))) &#123;        std::cout &lt;&lt; &quot;Lock acquired.&quot; &lt;&lt; std::endl;        tmtx.unlock();    &#125; else &#123;        std::cout &lt;&lt; &quot;Lock not acquired within timeout.&quot; &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    std::thread t1(try_lock_for_example);    std::thread t2(try_lock_for_example);    t1.join();    t2.join();    return 0;&#125;</code></pre><h4 id="std-recursive-mutex"><a href="#std-recursive-mutex" class="headerlink" title="std::recursive_mutex"></a><code>std::recursive_mutex</code></h4><p><code>std::recursive_mutex</code> 允许同一个线程多次锁定同一个互斥体，而不会死锁。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::recursive_mutex rmtx;void recursive_function(int count) &#123;    if (count &lt;= 0) return;    rmtx.lock();    std::cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; std::endl;    recursive_function(--count);    rmtx.unlock();&#125;int main() &#123;    std::thread t1(recursive_function, 10);    t1.join();    return 0;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++11 提供了多种类型的互斥体和相应的锁管理工具来确保线程安全：</p><ul><li><code>std::mutex</code>：基本的互斥体类型。</li><li><code>std::lock_guard</code>：RAII 风格的互斥体管理。</li><li><code>std::unique_lock</code>：更灵活的锁管理，支持延迟锁定、超时锁定等。</li><li><code>std::timed_mutex</code>：支持带超时的锁定操作。</li><li><code>std::recursive_mutex</code>：允许同一线程多次锁定。</li></ul><p>这些工具帮助程序员更方便和安全地编写多线程程序，确保对共享资源的访问是互斥的，从而避免数据竞争和潜在的并发问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis数据库存取结构体数组数据</title>
      <link href="/2024/03/02/redis/"/>
      <url>/2024/03/02/redis/</url>
      
        <content type="html"><![CDATA[<p><code>hiredis</code> 是一个 C 语言编写的 Redis 客户端库，用于与 Redis 数据库交互。如果你想要通过 hiredis 存储和检索结构体数组的信息，你需要编写相应的 C 代码来处理这些操作。</p><p>下面我将给出一个简单的示例，展示如何使用 hiredis 在 Redis 中存储和检索结构体数组信息。我们将使用 Redis 的 <code>HMSET</code> 和 <code>HGETALL</code> 命令来处理结构体数组。</p><p>首先，让我们定义一个结构体来模拟你的需求：</p><pre><code class="c">typedef struct User &#123;    char *name;    int age;&#125; User;// 函数声明void storeUserInRedis(struct User *user, long id);void getUserFromRedis(long id, struct User *user);void printUser(const struct User *user);int main(void) &#123;    // 初始化 hiredis 和连接 Redis    redisContext *c = redisConnect(&quot;127.0.0.1&quot;, 6379);    if (c == NULL || c-&gt;err) &#123;        if (c) &#123;            printf(&quot;Error: %s\n&quot;, c-&gt;errstr);            redisFree(c);        &#125; else &#123;            printf(&quot;Connection error: can&#39;t allocate redis context\n&quot;);        &#125;        return 1;    &#125;    // 创建用户结构体    struct User fred = &#123;&quot;Fred&quot;, 25&#125;;    struct User alice = &#123;&quot;Alice&quot;, 30&#125;;    // 生成用户 ID    redisReply *reply = (redisReply *)redisCommand(c, &quot;INCR id:users&quot;);    long fred_id = reply-&gt;integer;    freeReplyObject(reply);    // 存储用户信息    storeUserInRedis(&amp;fred, fred_id);    // 再次生成用户 ID    reply = (redisReply *)redisCommand(c, &quot;INCR id:users&quot;);    long alice_id = reply-&gt;integer;    freeReplyObject(reply);    // 存储用户信息    storeUserInRedis(&amp;alice, alice_id);    // 从 Redis 中获取用户信息    struct User retrieved_user;    getUserFromRedis(fred_id, &amp;retrieved_user);    printUser(&amp;retrieved_user);    // 清理资源    redisFree(c);    free(retrieved_user.name); // 释放内存    return 0;&#125;void storeUserInRedis(struct User *user, long id) &#123;    redisReply *reply = (redisReply *)redisCommand(NULL, &quot;HMSET user:%ld name %s age %d&quot;, id, user-&gt;name, user-&gt;age);    freeReplyObject(reply);&#125;void getUserFromRedis(long id, struct User *user) &#123;    redisReply *reply = (redisReply *)redisCommand(NULL, &quot;HGETALL user:%ld&quot;, id);    if (reply-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; reply-&gt;elements &gt;= 4) &#123;        user-&gt;name = strdup(reply-&gt;element[1]-&gt;str);        user-&gt;age = atoi(reply-&gt;element[3]-&gt;str);    &#125;    freeReplyObject(reply);&#125;void printUser(const struct User *user) &#123;    printf(&quot;Name: %s, Age: %d\n&quot;, user-&gt;name, user-&gt;age);&#125;</code></pre><p>这个示例程序包含了以下几个部分：</p><ol><li><strong>定义结构体</strong>: <code>struct User</code> 包含用户的姓名和年龄。</li><li><strong>连接 Redis</strong>: 使用 <code>redisConnect</code> 连接到 Redis 服务器。</li><li><strong>生成用户 ID</strong>: 使用 <code>INCR</code> 命令递增 <code>id:users</code> 键的值。</li><li><strong>存储用户信息</strong>: 使用 <code>storeUserInRedis</code> 函数，该函数接受用户结构体和 ID 作为参数，并使用 <code>HMSET</code> 命令存储数据。</li><li><strong>获取用户信息</strong>: 使用 <code>getUserFromRedis</code> 函数，该函数接受用户 ID 和指向用户结构体的指针，使用 <code>HGETALL</code> 命令从 Redis 中获取数据并填充结构体。</li><li><strong>打印用户信息</strong>: 使用 <code>printUser</code> 函数来打印用户信息。</li></ol><p>请注意，在实际应用中你需要确保所有动态分配的内存都被正确释放，例如在 <code>getUserFromRedis</code> 函数中通过 <code>strdup</code> 分配的内存。在上面的示例中，我在 <code>main</code> 函数的最后释放了 <code>retrieved_user.name</code> 的内存。</p><p>这个示例假设你已经在 Redis 中设置了 <code>id:users</code> 键，如果没有的话，你需要先初始化它（例如通过 <code>DEL id:users</code> 和 <code>INCR id:users</code>）。此外，你需要安装 hiredis 库并且在编译时链接它。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决spawn-fcgi:child exited with:127报错</title>
      <link href="/2024/02/01/127-bao-cuo/"/>
      <url>/2024/02/01/127-bao-cuo/</url>
      
        <content type="html"><![CDATA[<p>解决spawn-fcgi:child exited with: 127报错</p><p>spawn-fcgi:child exited with: 127<br>原因：没有找到动态库</p><p>输入指令：ldd 你要运行的程序名<br>来查看缺少的库，如图我确少的是 libfcgi.so.0<br><img src="/images/1722491883237.png"></p><p>解决方案<br>先执行命令，查找所缺文件位置，比如我的（你实际操作时候一定要记住库名换成自己的，-name后面）</p><p><code>find usr/local/lib/ -name &quot;libfcgi.so&quot;</code></p><p><img src="/images/1722492061360.png"></p><p>得到库文件所在路径<code>/usr/local/lib</code></p><p>再执行<code>sudo vi /etc/ld.so.conf</code><br>在文件里添加你得到的库文件路径<code>/usr/local/lib</code>，之后保存退出</p><p><img src="/images/1722492201079.png"></p><p>最后执行<code>sudo ldconfig</code></p><p>再回到原来目录重新编译运行就成功了</p><p><img src="/images/1722492227287.png"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
